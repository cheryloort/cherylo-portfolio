[["index.html", "Portfolio 1 Introductie", " Portfolio Cheryl 2025-01-05 1 Introductie Welkom bij mijn portfolio voor Data Science for Biology 2! "],["curriculum-vitae.html", "2 Curriculum vitae 2.1 Opleidingen 2.2 Werkervaring 2.3 Vaardigheden 2.4 Cursussen", " 2 Curriculum vitae Name: Jane Doe Adress: Janedoelane, 2010JD Mobile: (+55) 5 5555 5555 Mail: janedoe@example.com 2.1 Opleidingen NHL-Stenden Leeuwarden International Hotelmanagement (2021-2022) Propedeuse behaald in 2022 Hogeschool Utrecht Biologie en Medisch Laboratoriumonderzoek (2022-heden) - Specialisatie: Biomolecular Research - Minor: Data Science for Biology 2.2 Werkervaring Zorgcirkel Huishoudelijk medewerker (2021-2022) Gewoon Lekker Medewerker bediening (2022-2023) Pannenkoekenrestaurant Medewerker bediening (2022-heden) 2.3 Vaardigheden Data-analyse in R - Tidy maken van data. - Statistical tests uitvoeren, zoals correlatie en ANOVA. - Functions maken. - RMarkdown. - RNA-sequencing, waaronder de qualiteit bepalen van de reads, het alignen van de reads, PCA, etc. - Plotten van data. - Massa Spectrometry for R - Shiny app Data-analyse in bash - Scripts scrhijven. - Functions opstellen, inclusief flag parsing. SQL - Werken met relational databases in SQL. Laboratorium vaardigheden - Celkweek. - PCR. - DNA recombinatie. - Eiwittechnieken. Talen - Nederlands (moedertaal) - Engels (Gevorderd) - Frans (Beginner) - Duits (Beginner) 2.4 Cursussen NHA: Cursus Duits LOI: Cursus Digital Marketing LOI: Cursus Financieel Assistent "],["looking-ahead.html", "3 Looking ahead", " 3 Looking ahead Waar wil ik in 2 jaar tijd zijn? Over 2 jaar wil ik in iedergeval afgesturdeerd zijn en hopelijk begin ik dan aan een master in neuroscience, als dit niet lukt wil ik mezelf verder ontwikkelen in Data Science/ programmeren. Ik wil een stage hebben afgerond in het vakgebied van de neuroscience. Hoe staat het mij nu met betrekking tot dit doel? Op het gebied van neuroscience weet ik wel theoretische dingen, alleen nog niet hoe je data science kan toepassen op het gebied van neuroscience. Wat is de volgende stap om te leren? Onderzoeken welke toepassingen er zijn voor data science in het vakgebied van de neuroscience. Om dit te doen wil ik verder onderzoek gaan doen massaspectrometry data verwerking van biomarkers van neurodegeneratieve ziektes. Daarnaast heb ik ook nog een introductie gevolgd over de toepassing van seurat met neurologie data. Wat heb ik bereikt? Ik heb een massa spectrometrie analyse uitgevoerd op 2 data set, waarbij ik er bij een gefocused heb op de visualisatie, verwerking en manipulatie en bij de ander op de identificatie. Echter was het heel moeilijk om een juiste dataset te vinden voor de identificatie en waarneer ik dacht dat ik er eindelijk een had (waar ik nu de eerste stappen alsnog mee heb uitgevoerd) liep ik later vast omdat de structuur van het object te uitgebreid was. Wel heb ik veel geleerd over de visualisarie, verwerking en manipulatie van de data en weet ik hoe de functies in elkaar zitten en welk argument je wanneer gebruikt. Uiteindelijk was er nog vrij weinig te verdiepen in massa spectrometrie, vandaar dat ik verder ben gegaan met een introductie van Seurat. Met deze introductie heb ik onder andere geleerd om de data te filteren voor kwaliteit, de top genen en de expressie daarvan te visualiseren en de clusters visualiseren. "],["r-for-mass-spectrometry.html", "4 R for Mass Spectrometry 4.1 Introductie 4.2 Planning 4.3 Uitvoering met voorbeeld data PXDOOOOO1 4.4 Uitvoering met MS data PXD008990 4.5 Uitvoering met MS data PXD018226 4.6 Links", " 4 R for Mass Spectrometry 4.1 Introductie Massa spectrometrie is een technologie die ionen scheidt op basis van hun massa/lading ration (M/Z). In deze opdracht ga ik kijken naar de massa spectrometrie data van PXD008990. Deze studie kijkt naar leeftijdsgerelateerde glycomische en proteomische veranderingen in het nigrostriatal pathway van het brein. Bij Parkinson’s disease (PD) is er sprake van een progressieve degeneratie van dopaminerge neuronen in de nigrostriatal pathway. Gen therapie heeft potentie om deze degeneratie te vertragen of stoppen, adeno-associated virussen (AAV) zijn een voorbeeld van gen therapie. AAV receptoren zijn glycanen, in deze studie wordt er gefocussed op de receptor voor rAAV2 (heparansulfaat proteoglycaan), rAAV9 (N-glycanen met terminale galactose) en proteomics voor receptoren en co-receptoren van adeno-geassocieerd virus in het nigro-striatale gebied van de hersenen. 4.2 Planning 4.3 Uitvoering met voorbeeld data PXDOOOOO1 4.3.1 Inlezen van de data in R #Inlezen van PXD008990 in R px_vb &lt;- PXDataset(&quot;PXD000001&quot;) #Metadata bekijken van PXD008990 pxtax(px_vb) #Taxonomie van het dier ## [1] &quot;Erwinia carotovora&quot; pxurl(px_vb) #Website (url) waar de data vandaan komt ## [1] &quot;ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2012/03/PXD000001/generated&quot; pxref(px_vb) #Referentie naar het artikel ## [1] &quot;Gatto L, Christoforou A; Using R and Bioconductor for proteomics data analysis., Biochim Biophys Acta, 2013 May 18, doi:10.1016/j.bbapap.2013.04.032 PMID:23692960&quot; #Downloaden van bestand 2017-02-24-RR-SRT-Rat-25.mzM naar R met de pxget functie fn_vb &lt;- &quot;TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML&quot; mzf &lt;- pxget(px_vb, fn_vb) 4.3.2 Ruwe data visualisatie, verwerking en manipulatie sp_vb &lt;- Spectra(mzf) #Weergeef alle metadata variabelen spectraVariables(sp_vb) #Extract alle metadata spectraData(sp_vb) #Extract een lijst met de ruwe data peaksData(sp_vb) #Check het aantal spectra in het spectra object -&gt; dit is 7534 scans length(sp_vb) #Maak een nieuw kolom aan met de retentie tijden in minuten sp_vb$rtime_minute &lt;- rtime(sp_vb) / 60 with(spectraData(filterMsLevel(sp_vb, 1)), plot(rtime, totIonCurrent, type = &quot;l&quot;)) abline(v = rtime(sp_vb)[2807], col = &quot;red&quot;) #Verkrijg een parent set (MS1) en children (MS2) scans ms_2_vb &lt;- filterPrecursorScan(sp_vb, 2807) #Plot het 2807 spectrum en highlight alle pieken die voor MS2 analyse geselecteerd zijn plotSpectra(sp_vb[2807], xlim = c(400, 1000)) abline(v = precursorMz(ms_2_vb)[-1], col = &quot;grey&quot;) abline(v = precursorMz(ms_2_vb)[2], col = &quot;red&quot;) #Zoom in op mz values 521.1 en 522.5 om de isotope envelop van de pieken te weergeven plotSpectra(sp_vb[2807], xlim = c(521.2, 522.5), type = &quot;l&quot;) abline(v = precursorMz(ms_2_vb)[2], col = &quot;red&quot;) #Plot alle 10 de MS2 spectra plotSpectra(ms_2_vb[1:6]) sp2_vb &lt;- filterMsLevel(sp_vb, 2L) anyDuplicated(precursorMz(filterMsLevel(sp_vb, 2))) ## [1] 37 i &lt;- which(precursorMz(sp2_vb) == precursorMz(sp2_vb)[37]) sp2_vbi &lt;- sp2_vb[i] #Visualiseer het matchende paar plotSpectraOverlay(sp2_vbi, col = c(&quot;red&quot;, &quot;steelblue&quot;)) plotSpectraMirror(sp2_vbi[1], sp2_vbi[2]) 4.3.3 Identification data idf &lt;- msdata::ident(full.names = TRUE) basename(idf) ## [1] &quot;TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid&quot; #Inlezen van de mzIdentML (mzid) id &lt;- PSM(idf) #Het onderstaande tabel geeft het aantal spectra aan die 1, 2, 3, 4 of 5 matches hebben. table(table(id$spectrumID)) ## ## 1 2 3 4 5 ## 4936 369 26 10 2 #Om te zien hoeveel matches scan 1774 heeft: i &lt;- which(id$spectrumID == &quot;controllerType=0 controllerNumber=1 scan=1774&quot;) data.frame(id[i, ])[1:5] ## sequence spectrumID chargeState rank ## 1 RTRYQAEVR controllerType=0 controllerNumber=1 scan=1774 2 1 ## 2 RTRYQAEVR controllerType=0 controllerNumber=1 scan=1774 2 1 ## 3 RTRYQAEVR controllerType=0 controllerNumber=1 scan=1774 2 1 ## 4 RTRYQAEVR controllerType=0 controllerNumber=1 scan=1774 2 1 ## passThreshold ## 1 TRUE ## 2 TRUE ## 3 TRUE ## 4 TRUE #Reducing het PSM object met variabele sprectrumID id2 &lt;- reducePSMs(id, id$spectrumID) j &lt;- which(id2$spectrumID == &quot;controllerType=0 controllerNumber=1 scan=1774&quot;) #Zet de dataframe om naar een tibble id_tbl &lt;- tidyr::as_tibble(id) #Verwijder decoy hits id_tbl &lt;- id_tbl %&gt;% filter(!isDecoy) #Houd de first rank matches id_tbl &lt;- id_tbl %&gt;% filter(rank == 1) #Verwijder de gedeelde peptides mltm &lt;- id_tbl %&gt;% group_by(spectrumID) %&gt;% mutate(nProts = length(unique(DatabaseAccess))) %&gt;% filter(nProts &gt; 1) %&gt;% select(spectrumID, nProts) id_tbl &lt;- id_tbl %&gt;% filter(!spectrumID %in% mltm$spectrumID) #Je kan ook je data filteren met filterPMS(), beide geven een output van 2666 PSMs id_filtered &lt;- filterPSMs(id) #describePeptides geeft het aantal unieke of gedeelde peptides describePeptides(id_filtered) #Zou alleen unieke hits moeten geven aangezien de gedeelde eruit zijn gefilterd #describeProteins geeft het aantal eiwitten/proteins gedefinieerd door alleen unieke, alleen gedeelde of een mix van beide. describeProteins(id_filtered) #Vergelijk de distributie van ruwe identificatie scores van de decoy en de niet-decoy hits as_tibble(id) %&gt;% ggplot(aes(x = MS.GF.RawScore, colour = isDecoy)) + geom_density() #Bereken de lengte van elke peptide en het aantal peptides per eiwit en plot de lengte van de peptide tegen hun respectieve aantal peptides suppressPackageStartupMessages(library(&quot;dplyr&quot;)) iddf &lt;- as_tibble(id_filtered) %&gt;% mutate(peplen = nchar(sequence)) npeps &lt;- iddf %&gt;% group_by(DatabaseAccess) %&gt;% tally iddf &lt;- full_join(iddf, npeps) ## Joining with `by = join_by(DatabaseAccess)` library(&quot;ggplot2&quot;) ggplot(iddf, aes(x = n, y = DBseqLength)) + geom_point() Combineren van identification data met de ruw data #Spectra met meerdere PSMs table(table(id_filtered$spectrumID)) ## ## 1 2 3 4 ## 2630 13 2 1 #Zoeken welk spectrum 4 matching PSMs heeft which(table(id_filtered$spectrumID) == 4) ## controllerType=0 controllerNumber=1 scan=5490 ## 1903 #Filter dit spectrum uit de data en maak een dataframe ervan id_4 &lt;- id_filtered[id_filtered$spectrumID == &quot;controllerType=0 controllerNumber=1 scan=5490&quot;, ] %&gt;% as.data.frame() #De vier PSM verschillen in locatie van de Carbamidomethyl modificatie, dit kan je zien in de dataframe of selecteren met: id_4[, c(&quot;modName&quot;, &quot;modLocation&quot;)] ## modName modLocation ## 1 Carbamidomethyl 2 ## 2 Carbamidomethyl 5 ## 3 Carbamidomethyl 10 ## 4 Carbamidomethyl 15 #De PMS table reduceren om alleen een-op-een matches tussen ruwe spectra en PSMs te krijgen id_filtered &lt;- reducePSMs(id_filtered, id_filtered$spectrumID) #Dan kan je het spectra object en de PSM table samenvoegen sp_vb &lt;- joinSpectraData(sp_vb, id_filtered, by.x = &quot;spectrumId&quot;, by.y = &quot;spectrumID&quot;) #Na gaan of er geen identificatie data is toegevoegd aan de MS1 scans all(is.na(filterMsLevel(sp_vb, 1)$sequence)) ## [1] TRUE #Na gaan of het wel is toegevoegd aan de MS2 scans sp2_vb &lt;- filterMsLevel(sp_vb, 2) table(is.na(sp2_vb$sequence)) ## ## FALSE TRUE ## 2646 3457 #Vergelijk de precursor/ peptide mass to charges sp2_vb &lt;- sp2_vb[!is.na(sp2_vb$sequence)] summary(sp2_vb$precursorMz - sp2_vb$experimentalMassToCharge) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0000 0.0000 0.0000 0.0053 0.0000 2.0297 #Tel het aantal identificaties voor elke scan sp_vb &lt;- countIdentifications(sp_vb) #Toon het aantal PSMs per scan. table(msLevel(sp_vb), sp_vb$countIdentifications) ## ## 0 1 2 3 4 5 6 7 8 9 10 ## 1 833 30 45 97 139 132 92 42 17 3 1 ## 2 3457 2646 0 0 0 0 0 0 0 0 0 #Visualisatie van de data in de total ion chromatogram sp_vb |&gt; filterMsLevel(1) |&gt; spectraData() |&gt; as_tibble() |&gt; ggplot(aes(x = rtime, y = totIonCurrent)) + geom_line(alpha = 0.25) + geom_point(aes(colour = ifelse(countIdentifications == 0, NA, countIdentifications)), size = 0.75, alpha = 0.5) + labs(colour = &quot;Number of ids&quot;) #Kies een MS2 Spectrum met een hoge identificatie score en plot het i &lt;- which(sp_vb$MS.GF.RawScore &gt; 100)[1] plotSpectra(sp_vb[i]) #Gebruik de addFragments() functie om de pieken te annoteren plotSpectra(sp_vb[i], labels = addFragments, labelPos = 3, labelCol = &quot;steelblue&quot;) #Matching observed peaks to fragments sp_vb[i]$sequence ## [1] &quot;THSQEEMQHMQR&quot; calculateFragments(sp_vb[i]$sequence) %&gt;% head(n = 10) ## mz ion type pos z seq ## 1 102.0550 b1 b 1 1 T ## 2 239.1139 b2 b 2 1 TH ## 3 326.1459 b3 b 3 1 THS ## 4 454.2045 b4 b 4 1 THSQ ## 5 583.2471 b5 b 5 1 THSQE ## 6 712.2897 b6 b 6 1 THSQEE ## 7 843.3301 b7 b 7 1 THSQEEM ## 8 971.3887 b8 b 8 1 THSQEEMQ ## 9 1108.4476 b9 b 9 1 THSQEEMQH ## 10 1239.4881 b10 b 10 1 THSQEEMQHM Comparing Spectra # Maak een new object met de MS2 spectra met sequenties &quot;SQILQQAGTSVLSQANQVPQTVLSLLR&quot; en &quot;TKGLNVMQNLLTAHPDVQAVFAQNDEMALGALR&quot; k &lt;- which(sp_vb$sequence %in% c(&quot;SQILQQAGTSVLSQANQVPQTVLSLLR&quot;, &quot;TKGLNVMQNLLTAHPDVQAVFAQNDEMALGALR&quot;)) sp_k &lt;- sp_vb[k] sp_k ## MSn data (Spectra) with 5 spectra in a MsBackendMzR backend: ## msLevel rtime scanIndex ## &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt; ## 1 2 2687.42 5230 ## 2 2 2688.88 5235 ## 3 2 2748.75 5397 ## 4 2 2765.26 5442 ## 5 2 2768.17 5449 ## ... 69 more variables/columns. ## ## file(s): ## 16a7c6761dc79_TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML # Bereken de 5 bij 5 gelijkenismatrix tussen alle spectra met behulp van compare spectra mat &lt;- compareSpectra(sp_k) rownames(mat) &lt;- colnames(mat) &lt;- strtrim(sp_k$sequence, 2) # Maak een heatmap van de bovenstaande resultaten pheatmap::pheatmap(mat) # Vergelijk de spectra met plotting functies filterIntensity(sp_k, 1e3) %&gt;% plotSpectra(main = sp_k$sequence) par(mfrow = c(3, 1)) plotSpectraMirror(sp_k[1], sp_k[2], main = &quot;TK...&quot;) plotSpectraMirror(sp_k[3], sp_k[4], main = &quot;SQ...&quot;) plotSpectraMirror(sp_k[3], sp_k[4], main = &quot;SQ...&quot;) 4.3.4 MSnbase package # Inlezen van de data ms &lt;- openMSfile(mzf) hd &lt;- header(ms) # Spectra tussen 30 en 35 minuten retentietijd selecteren ms1 &lt;- which(hd$msLevel == 1) rtsel &lt;- hd$retentionTime[ms1] / 60 &gt; 30 &amp; hd$retentionTime[ms1] / 60 &lt; 35 # De map M &lt;- MSmap(ms, ms1[rtsel], 521, 523, .005, hd, zeroIsNA = TRUE) plot(M, aspect = 1, allTicks = FALSE) plot3D(M) 4.4 Uitvoering met MS data PXD008990 4.4.1 Inlezen van de data in R #Inlezen van PXD008990 in R px &lt;- PXDataset(&quot;PXD008990&quot;) #Bekijken van alle bestanden die horen bij PXD008990 pxfiles(px) #Metadata bekijken van PXD008990 pxtax(px) #Taxonomie van het dier ## [1] &quot;Rattus norvegicus (rat)&quot; pxurl(px) #Website (url) waar de data vandaan komt ## [1] &quot;ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2018/06/PXD008990&quot; pxref(px) #Referentie naar het artikel ## [1] &quot;Raghunathan R, Polinski NK, Klein JA, Hogan JD, Shao C, Khatri K, Leon D, McComb ME, Manfredsson FP, Sortwell CE, Zaia J. Glycomic and Proteomic Changes in Aging Brain Nigrostriatal Pathway. Mol Cell Proteomics. 2018 17(9):1778-1787 doi:10.1074/mcp.ra118.000680 PMID:29915149&quot; #Downloaden van bestand 2017-02-24-RR-SRT-Rat-25.mzM naar R met de pxget functie filename &lt;- &quot;2017-02-24-RR-SRT-Rat-25.mzML&quot; Rat_25.mzML &lt;- pxget(px, filename) 4.4.2 Ruwe data visualisatie, verwerking en manipulatie Spectra Spectra objecten zijn lijsten van individuele sprectra, elk spectrum is geassocieerd met een set van variabelen (bijvoorbeeld MS level en retentietijd). De core variabelen van spectra objecten zijn: spectra &lt;- Spectra(Rat_25.mzML) #Weergeef alle metadata variabelen spectraVariables(spectra) #Extract alle metadata spectraData(spectra) #Extract een lijst met de ruwe data peaksData(spectra) #Check het aantal spectra in het spectra object length(spectra) #Maak een nieuw kolom aan met de retentie tijden in minuten spectra$rtime_minute &lt;- rtime(spectra) / 60 spectra$rtime_minute %&gt;% head() #Kijken hoeveel MS levels er zijn unique(spectra$msLevel) #Verkrijg de index van het MS2 spectrum met de hoogste base peak intensity ms2_bpi &lt;- filterMsLevel(spectra, 2) ms2_bpi_max &lt;- which.max(ms2_bpi$basePeakIntensity) max_scanIndex &lt;- ms2_bpi$scanIndex[ms2_bpi_max] max_scanIndex De spectra data is opgeslagen in object spectra, een spectra object bevat MS data over de mass peak data en de metadata van een individueel spectrum. Met spectraVariables kan je checken welke variabelen er allemaal aanwezig zijn in jouw spectra object. Met spectraData kan je alle een lijst verkrijgen met alle metadata en met peaksData kan je een lijst verkrijgen met de ruwe data. Om het aantal spectra in een object te weergeven kan je length gebruiken, in dit geval zijn er 37016 spectra. Om bijvoorbeeld na te gaan hoeveel MS levels er zijn kan je gebruik maken van unique(spectra$msLevel), voor deze data zijn er twee MS levels; MS1 en MS2. Als je de index van het MS2 spectrum met de hoogste base peak intensity wilt verkrijgen moet je eerst filteren voor MS level 2 met filterMsLevel, dan de max bepalen met which.max en dan de scanIndex van de maximale base peak intensity afleiden. De scanIndex van het MS2 spectrum met de hoogste base peak intensity is in dit geval 10222. Backends Backends maken het mogelijk om verschillende backends te gebruiken om massa spectrometrie data in op te slaan, terwijl het via de Spectra-klasse een uniform interface biedt om die gegevens te gebruiken. Verschillende backends: - MsBackendMzR: deze backend bewaard alleen algemene spectra variabelen en berust op het mzR pakket om massa peaks van de orginele MS-bestanden te lezen. - MsBackendMemory &amp; MsBackendDataFrame: de volledige MS data is opgeslagen in het geheugen van het object. - MsBackendHdf5Peaks: leest alleen peakgegevens op aanvraag, terwijl alle andere spectra variabelen in geheugen worden bewaard. De piekgegevens worden opgeslagen in Hdf5-bestanden. - MsBackendSql: alle data opslaan in een SQL database. filtered_m1 &lt;- filterMsLevel(spectra, 1) plot(filtered_m1$rtime, filtered_m1$totIonCurrent, type = &quot;h&quot;) abline(v = rtime(spectra)[10200], col = &quot;red&quot;) Met de bovenstaande code wordt MS level 1 gefilterd uit het spectra object en vervolgens wordt de data weergeven in een grafiek. De retentietijd (rtime) komt op de x-as en de totale ion current (totIonCurrent) op de y-as. Voor type kan je verschillende soorten gebruiken, type “l” geeft een doorlopende lijn, type “h” geeft data als staven en type “p” geeft data als losse punten. Met abline kan je een scan naar keuze kiezen. #Verkrijg een set parent (MS1) en children (MS2) scans ms_2 &lt;- filterPrecursorScan(spectra, 10200) #Weergeven van de precursorMz waardes van ms_2 precursorMz(ms_2) ## [1] NA 809.3505 579.8279 523.2855 412.7531 558.2895 395.8815 506.7640 ## [9] 515.3225 464.1941 611.2835 549.9726 353.6746 563.7582 887.9309 837.3717 ## [17] 724.1328 357.7287 685.3317 933.1257 575.3111 #Plot het MS spectrum van scan 3000 en highlight alle pieken die voor MS2 analyse geselecteerd worden plotSpectra(spectra[10200], xlim = c(400, 1000)) abline(v = precursorMz(ms_2)[-1], col = &quot;grey&quot;) abline(v = precursorMz(ms_2)[2:7], col = &quot;red&quot;) #Zoom in op mz values 578 en 580 om de isotope envelop van de pieken te weergeven plotSpectra(spectra[10200], xlim = c(578, 580), type = &quot;l&quot;) abline(v = precursorMz(ms_2)[3], col = &quot;red&quot;) Met filterPrecursorScan(spectra, 10200) wordt alle data van scan 10200 in een apart object overgebracht. In dit object is te zien dat er 21 data punten bij horen. Waaronder ook 21 precursorMz waardes. Met precursorMz(ms_2)[-1] wordt de NA waarde van de precursorMz waardes overgeslagen, de rest wordt als grijze lijnen in het spectrum weergeven. Met de rode lijnen kunnen de spectra geselecteerd worden die later voor MS2 analyse gebruikt zullen worden, in dit geval heb zijn spectra 2:7 geselecteerd. Daarna is er met plotSpectra(spectra[10200], xlim = c(578, 580), type = \"l\") en abline(v = precursorMz(ms_2)[3]) verder ingezoomd op precursorMz waarde 3 (579.8279). Hierin is waarde 3 dus met een rode lijn weergeven. #Plot alle 10 de MS2 spectra plotSpectra(ms_2[2:7]) Met plotSpectra(ms_2[1:6]) worden de 2e t/m 7e MS2 spectra van scan 10200 weergeven. sp2 &lt;- filterMsLevel(spectra, 2L) anyDuplicated(precursorMz(filterMsLevel(spectra, 2))) ## [1] 2492 i_pd &lt;- which(precursorMz(sp2) == precursorMz(sp2)[2492]) sp2_i &lt;- sp2[i_pd] #Visualiseer het matchende paar plotSpectraOverlay(sp2_i, xlim = c(50, 600), col = c(&quot;#DB7093&quot;, &quot;steelblue&quot;)) legend(&quot;topright&quot;, col = c(&quot;#DB7093&quot;, &quot;steelblue&quot;), legend = sp2_i$scanIndex, pch = 15) # Label functie mzLabel &lt;- function(z) { z &lt;- peaksData(z)[[1L]] lbls &lt;- format(z[, &quot;mz&quot;], digits = 4) lbls[z[, &quot;intensity&quot;] &lt; 1e5] &lt;- &quot;&quot; lbls } plotSpectraMirror(sp2_i[1], sp2_i[2], xlim = c(0, 500), col = c(&quot;pink&quot;, &quot;steelblue&quot;), labels = mzLabel, labelPos = 2, labelCol = &quot;#36454F&quot;, matchPch = 20) Met plotSpectraOverlay en plotSpectraMirror kunnen overeenkomende spectra vergeleken worden. Hiervoor wordt eerst MS level 2 gefilterd met filterMsLevel. Met anyDuplicated wordt er gecontroleerd of er duplicaten zijn in de precursor m/z waarde van de scans. Dit geeft aan dat scan 2492 duplicaten heeft. Met which(precursorMz(sp2) == precursorMz(sp2)[2492]) wordt gezocht naar scans die dezelfde precursor m/z waarde hebben als de 2492e scan, dit geeft scans 4466 en 7390 als duplicaten. Met plotSpectraOverlay worden de spectra van interesse over elkaar heen geplot, hierdoor kun je de verschillen of overeenkomsten in intensiteiten en m/z waarden visualiseren. Het argument col = c(\"red\", \"steelblue\") van de plotSpectraOverlay geeft aan dat het eerste spectrum in de lijst pale violet red gekleurd zal worden en het tweede spectrum in de lijst steelblue. In de legend staat de bijhorende scanIndex weergeven van de kleuren. Met plotSpectraMirror worden twee spectra weerspiegeld ten opzich van elkaar geplot, sp2_i[1] wordt normaal weergeven en sp2_i[2] wordt gespiegeld. Met xlim = c(0, 500) is de range voor m/z waardes van 0 tot 500 gezet, boven de 500 zijn er amper pieken en geen matchende pieken. Met col = (“pink”, “steelblue”) is het mogelijk gemaakt om onderscheid te maken tussen pieken die als match worden gezien en pieken die niet als match worden gezien. # Bepaal een filter functie low_int &lt;- function(x, ...) { x &gt; max(x, na.rm = TRUE) * 0.10 } # Gebruik de functie om de spectra te filteren sps &lt;- filterIntensity(spectra, intensity = low_int) # Functie voor label benaming mzLabel &lt;- function(z) { z &lt;- peaksData(z)[[1L]] lbls &lt;- format(z[, &quot;mz&quot;], digits = 4) lbls[z[, &quot;intensity&quot;] &lt; 1e5] &lt;- &quot;&quot; lbls } # Plot spectra met gefilterde data en labels plotSpectra(sps[10200], xlim = c(410, 460), labels = mzLabel, labelPos = 4, labelOffset = 0.3, labelCex = 0.8, labelCol = &quot;#36454F&quot;) plotSpectra(spectra[10200], xlim = c(421, 422), type = &quot;l&quot;) Om de pieken met lage intensiteit te verwijderen wordt er gebruik gemaakt van een functie in combinatie met filterIntensity. In het bovenstaande voorbeeld zijn de pieken met een intensiteit lager dan 10% van de maximale intensiteit van elk spectrum verwijderd. In vergelijking met de chunk visualitatie MS1 en MS2 csf `zijn er heel veel pieken verwijderd, boven de 450.3 m/z zijn er niet eens pieken zichtbaar meer. Ook zijn de pieken gelabeld met hun bijhorende m/z waarde. 4.4.3 Samenvattings opdracht # Download de eerste 3 mzML files van PX008990 (mzmls &lt;- rpx::pxget(px, grep(&quot;mzML&quot;, pxfiles(px))[1:3])) ## [1] &quot;/Users/cheryloortwijn/Library/Caches/org.R-project.R/R/rpx/10881571c9ff2_03062017-RR_SN-Rat-18-rerrun.mzML&quot; ## [2] &quot;/Users/cheryloortwijn/Library/Caches/org.R-project.R/R/rpx/1013c6488d150_03062017-RR_SN-Rat-19-rerrun.mzML&quot; ## [3] &quot;/Users/cheryloortwijn/Library/Caches/org.R-project.R/R/rpx/108815df0c6c8_03062017-RR_SN-Rat-20-rerun.mzML&quot; # Maak een spectra object ervan sp3_pd &lt;- Spectra(mzmls) # Om te zien hoeveel spectra elk bestand heeft table(basename(sp3_pd$dataOrigin)) ## ## 1013c6488d150_03062017-RR_SN-Rat-19-rerrun.mzML ## 35931 ## 10881571c9ff2_03062017-RR_SN-Rat-18-rerrun.mzML ## 36451 ## 108815df0c6c8_03062017-RR_SN-Rat-20-rerun.mzML ## 36799 # Kijken of alle levels centroided zijn table(sp3_pd$centroided, sp3_pd$msLevel) ## ## 1 2 ## TRUE 55382 53799 ## Chromatogram van de 3 bestanden gecombineerd filterMsLevel(sp3_pd, 1) %&gt;% spectraData() %&gt;% as_tibble() %&gt;% ggplot(aes(x = rtime, y = totIonCurrent, colour = basename(dataOrigin))) + geom_line() Het is ook mogelijk om drie bestanden te vergelijken, hiervoor moeten de bestanden eerst verkregen worden met pxget. Als ook het spectrum verkregen is kan je een chromatogram van de 3 bestanden maken. De bestanden hebben verschillende kleuren in het chromatogram. Aangezien het reruns zijn, is het logisch dat de spectra er ongeveer hetzelfde uitzien. 4.4.4 MSnbase package Plotting Raw Data # Inlezen van de data ms_csf &lt;- openMSfile(Rat_25.mzML) hd_csf &lt;- header(ms_csf) ms1_csf &lt;- which(hd_csf$msLevel == 1) rtsel_csf &lt;- hd_csf$retentionTime[ms1_csf] / 60 &gt; 50 &amp; hd_csf$retentionTime[ms1_csf] / 60 &lt; 60 # M_csf &lt;- MSmap(ms_csf, ms1_csf[rtsel_csf], 578, 582, .03, hd_csf, zeroIsNA = TRUE) # Plot het spectrum plot(M_csf, aspect = 1, allTicks = FALSE) Eerst wordt de data ingelezen met openMSfile, deze functie verwijst naar het openen van een bestand dat massa-spectrometriegegevens bevat, met als doel de gegevens te lezen en verder te verwerken voor analyse. De header functie retourneert een dataframe met de spectra parameters van de scans (alleen MSn). Met which(hd_csf$msLevel == 1) worden alle spectra met MS level een gefilterd. Het rtsel_csf object bevat de gewenste retentietijden, in dit geval is er gekozen voor boven de 50 en onder de 60. In M_csf staat de informatie opgeslagen voor de map. Met MSmap kan je selecteren welke informatie je wilt, 578 is de ondergrens van het m/z bereik, 582 is de bovengrens, 0.3 is de resolutie (de dikte van de lijntjes in de map) en zeroIsNA zet intensiteiten van 0 om naar NA. Met plot wordt de grafiek vervolgens gemaakt, aspect = 1 staat voor een vierkante plot en allTicks = FALSE zorgt ervoor dat niet alle ticks (de markers langs de assen van de plot) getoont worden. Met de heatmap wordt de intensiteit van het signaal weergeven. In de grafiek kan je terug zien dat de hoogste intensiteit (de donkerste blauwe kleur) voornamelijk terug te zien is rond m/z waarde 579. Het onderstaande plot is gebaseerd op dezelfde gegevens, als het bovenstaande plot. Ook hier is de hoogste intensiteit te zien rond m/z waarde 579. plot3D(M_csf) csf_i &lt;- ms1_csf[which(rtsel_csf)][4] csf_j &lt;- ms1_csf[which(rtsel_csf)][5] M2_csf &lt;- MSmap(ms_csf, csf_i:csf_j, 100, 1000, 1, hd_csf) plot3D(M2_csf) In deze 3D plot zijn de 4e en 5e MS1 spectra te zien van de eerste map (M_csf) en alle tussenliggende MS spectra. Op de oranje lijnen zien de MS2 pieken te zien, in dit geval zitten de meeste MS2 pieken voor de retentietijd van 400 en op de 2e lijn van rechts. Quality Control # Zet de kolommen van hd_csf zo om dat ze gebruikt kunnen worden voor het z argument plot2d &lt;- dplyr::rename(hd_csf, retention.time= retentionTime, precursor.mz= precursorMZ, peaks.count= peaksCount, charge= precursorCharge, ionCount= totIonCurrent) #Plot 2d met als kleuring peaks count en charge plot2d(plot2d, z=&quot;peaks.count&quot;, alpha = 0.2, plot = TRUE) plot2d(plot2d, z=&quot;charge&quot;, alpha = 0.3, plot = TRUE) # Filter de plots op seqNum 20000 tot 21000 om een overzichtelijkere weergave te krijgen plot2d_filtered &lt;- plot2d %&gt;% filter(seqNum %in% c(20000:21000)) %&gt;% filter(charge %in% c(3,4,5)) plot2d(plot2d_filtered, z=&quot;charge&quot;, alpha = 0.3, plot = TRUE) De punten in de bovenstaande plots representeren individuele MS2 spectra. In het eerste plot zijn de punten gekleurd gebaseerd op aantal pieken (peaks count) en in het tweede plot zijn ze gekleurd gebaseerd op de precursor charge. In het derde plot is er gefilterd op seqNum 20000 tot 21000 en charge 3, 4 of 5 (dit is random gekozen) zodat er minder data punten zijn om een overzichtelijker plot te verkrijgen. Hierin kan de dan ook zien dan een charge van 5 in verhouding tot charge 3 en 4 weinig voorkomt en als het wel voorkomt is dit meestal bij een hoge precursor mz. plot2d_na &lt;- plot2d[!is.na(plot2d$charge), ] plotDensity(plot2d_na, z=&quot;peaks.count&quot;, plot = TRUE) ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. plotDensity(plot2d_na, z=&quot;precursor.mz&quot;, plot = TRUE) ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. Met plotDensity is handig voor het visualiseren van de distributie van bijvoorbeeld ion intensities. Bij beide is de hoogste dichtheid zichtbaar bij een charge van 2 en bij 5 en 6 is er een hele lage dichtheid. 4.5 Uitvoering met MS data PXD018226 Medulloblastoma (MB) is een embryonale tumor van het cerebellum. MB gaat vaak gepaard met leptomeningeal dissemination, dit is de detectie van kankercellen in de leptomeningnes (arachnoid en pia mater), de subarachnoïde ruimte en in cerebrospinale vloeistof (CSF). Er is weinig bekend over de micro-omgeving van MB en het terugkeren van MB. In deze studie wordt er multi-omics massa spectrometrie uitgevoerd op CSF van patiënten met terugkerende MB. 4.5.1 Inlezen van data in R # Inlezen van PXD018226 in R px_csf &lt;- PXDataset(&quot;PXD018226&quot;) # Downloaden van bestand CSF_MB_7_1.mzML naar R met de pxget functie fn_csf &lt;- &quot;CSF_MB_7_1.mzML&quot; CSF_MB_7_1.mzML &lt;- pxget(px_csf, fn_csf) sp_csf &lt;- Spectra(CSF_MB_7_1.mzML) 4.5.2 Ruwe data visualisatie with(spectraData(filterMsLevel(sp_csf, 1)), plot(sp_csf$rtime, sp_csf$totIonCurrent, type = &quot;l&quot;)) #Om de retentietijd van scan 8700 af te kunnen lezen abline(v = rtime(sp_csf)[8605], col = &quot;red&quot;) #Verkrijg een set parent (MS1) en children (MS2) scans ms2_csf &lt;- filterPrecursorScan(sp_csf, 8605) #Weergeven van de precursorMz waardes van ms2_csf precursorMz(ms2_csf) ## [1] 729.3318 #Plot het MS spectrum van scan 3000 en highlight alle pieken die voor MS2 analyse geselecteerd worden plotSpectra(sp_csf[8605], xlim = c(100, 750)) abline(v = precursorMz(ms2_csf)[1], col = &quot;grey&quot;) abline(v = precursorMz(ms2_csf)[1], col = &quot;red&quot;) Spectra kunnen ook vergeleken worden door overlay of mirror plotting met de plotSpectraOverlay() en plotSpectraMirror() functies. #Vinden van de overeenkomende paren sp2_csf &lt;- filterMsLevel(sp_csf, 2L) anyDuplicated(precursorMz(filterMsLevel(sp_csf, 2))) i_csf &lt;- which(precursorMz(sp2_csf) == precursorMz(sp2_csf)[96]) sp2i_csf &lt;- sp2_csf[i_csf] #Visualiseren van de overeenkomende paren plotSpectraOverlay(sp2i_csf, col = c(&quot;red&quot;, &quot;steelblue&quot;)) plotSpectraMirror(sp2i_csf[1], sp2i_csf[2]) 4.5.3 Identification data #Inlezen van mzid bestand CSF_MB_7_1.mzid.gz door eerst met pxget het bestand te downloaden en daarna met PSM fn_csf_id &lt;- &quot;CSF_MB_7_1.mzid.gz&quot; CSF_MB_7_1.mzid.gz &lt;- pxget(px_csf, fn_csf_id) id_csf &lt;- PSM(CSF_MB_7_1.mzid.gz) ## No scoring information available #Het onderstaande tabel geeft het aantal matches per spectrum aan table(table(id_csf$spectrumID)) ## ## 1 2 3 4 5 6 8 10 ## 3532 426 130 35 9 7 1 1 #Achterhaal welke scan 10 matches heeft match_counts &lt;- table(id_csf$spectrumID) spectra_with_10_matches &lt;- names(match_counts[match_counts == 10]) #Om de matches te zien scan 7490 heeft: matches_csf &lt;- which(id_csf$spectrumID == &quot;scan=7490 file=3445&quot;) data.frame(id_csf[matches_csf, ])[1:5] ## sequence spectrumID chargeState rank passThreshold ## 1 BIZMTQSPSSLSASVGDR scan=7490 file=3445 2 4 TRUE ## 2 BIZMTQSPSSLSASVGDR scan=7490 file=3445 2 4 TRUE ## 3 BIZMTQSPSSLSASVGDR scan=7490 file=3445 2 4 TRUE ## 4 BIZMTQSPSSLSASVGDR scan=7490 file=3445 2 4 TRUE ## 5 BIZMTQSPSSLSASVGDR scan=7490 file=3445 2 2 TRUE ## 6 BIZMTQSPSSLSASVGDR scan=7490 file=3445 2 2 TRUE ## 7 BIZMTQSPSSLSASVGDR scan=7490 file=3445 2 2 TRUE ## 8 BIZMTQSPSSLSASVGDR scan=7490 file=3445 2 2 TRUE ## 9 DIQMTQSPSSLSASVGDR scan=7490 file=3445 2 1 TRUE ## 10 DIQMTQSPSSLSASVGDR scan=7490 file=3445 2 1 TRUE #Reducing het PSM object met variabele sprectrumID id2_csf &lt;- reducePSMs(id_csf, id_csf$spectrumID) #Scan 7490 heeft nu in plaats van 10 PSM&#39;s maar 1 PSM j_csf &lt;- which(id2_csf$spectrumID == &quot;scan=7490 file=3445&quot;) id2_csf[j, ] ## Reduced PSM with 1 rows and 29 columns. ## names(29): sequence spectrumID ... subReplacementResidue subLocation Met table(table(id_csf$sprectrumID)) is het aantal matches per spectrum berekend en daar is weer een tabel van gemaakt, hier zie je dat er een spectrum is die 10 matches heeft. Om te achterhalen welke scan 10 matches heeft wordt eerst de volledige data van het aantal matches per spectrum verkregen met table(id_csf$spectrumID) en vervolgens wordt hierin gezocht wat de naam is van match count 10, met names(match_counts[match_counts == 10]). Het spectrum met 10 match counts is “scan=7490 file=3445”. Met which(id_csf$spectrumID == \"scan=7490 file=3445\") worden de rijen naar voren gehaald die matchen met dit spectrumID. Vervolgens wordt met data.frame(id_csf[matches_csf, ])[1:5] de eerste 5 variabelen van deze matches in een dataframe weergeven. Met reducePSMs wordt het aantal PSMs gereduceerd, vaak door het combineren van PSMs die overeenkomen met dezelfde peptide. # Filter voor decoy false waardes, voor rank == 1 en voor gedeelde peptiden. id_csf_fil &lt;- filterPSMs(id_csf) # Samenvatting van de peptides en proteins in de PSM resultaten describePeptides(id_csf) describePeptides(id_csf_fil) describeProteins(id_csf) describeProteins(id_csf_fil) De id_csf data wordt met filterPSMs(id_csf) gefilterd voor isDecoy = FALSE waardes, voor PSMs met een rank van 1 en voor gedeelde peptiden. De resultaten geven aan dat er geen decoy hits zijn verwijderd, dat er 26 PSMs met een rank hoger dan 1 zijn verwijderd en dat er 465 gedeelde peptiden zijn verwijderd. Uiteindelijk blijven er van de 5019 PSMs nog 4528 over. Met describePeptides en describeProteins kan er een samenvatting worden gegeven van de peptides en proteins in de PSM resultaten. Eerst is dit uitgevoerd op de ongefilterde data, de describePeptides gaf 2599 unieke peptides en 127 gedeelde peptiden, welk weer verdeeld waren over 4 proteins. Na filteren blijven er nog 2590 peptiden over, waarvan alles uniek is. De describeProteins gaf 575 eiwitten, waarvan er 522 uniek zijn en 53 zijn uniek en gedeeld. Na filteren blijven er nog 574 eiwitten over, deze zijn allemaal uniek. # Maak een tibble van de gefilterde data id_csf_tbl &lt;- tidyr::as_tibble(id_csf_fil) # Maak een plot waarin je de lengte van de eiwitten uit zet tegen hun respectieve aantal peptiden. id_csf_tbl &lt;- id_csf_tbl %&gt;% mutate(peplen = nchar(sequence)) npeps_csf &lt;- id_csf_tbl %&gt;% group_by(DatabaseAccess) %&gt;% tally id_csf_tbl &lt;- full_join(id_csf_tbl, npeps_csf, by = join_by(DatabaseAccess)) ggplot(id_csf_tbl, aes(x = id_csf_tbl$n, y = id_csf_tbl$DBseqLength)) + geom_point() # Maak nog een plot waar n gefilterd is op waardes onder de 20 om een beter overzicht te hebben plot_csf &lt;- id_csf_tbl %&gt;% filter(n &lt; 20) ggplot(plot_csf, aes(x = n, y = DBseqLength)) + geom_point() Van de gefilterde data is een tibble gemaakt, vervolgens is met mutate een kolom toegevoegd met de peptide lengte. De peptide lengte is berekent met nchar(sequence). Daarna wordt de DatabaseAccess kolom gegroepeerd en in het nieuwe object npeps_cs is per groupering het aantal rijen te zien, dit is getelt met de tally functie. Het kolom DatabaseAccess bevat de eiwitnamen/ symbolen. De tibble data is vervolgens geplot, dit is het bovenste figuur. Doordat hier ook hoge x-as waardes bijzitten maar vooral veel lage x-as waardes zijn de punten op de linkerkant van de x-as moeilijk te onderscheiden. Om dit op te lossen is er nog een grafiek gemaakt met alleen n waardes onder de 20, dit grafiek bevat dus niet alle data maar is enkel voor een beter overzicht/ betere weergave! 4.5.4 Combineren van identificatie data met ruwe data # In de gefilterde data zijn er nog steeds meerdere PSMs die aan een enkel spectrum gekoppeld zijn table(table(id_csf_fil$spectrumID)) ## ## 1 2 3 4 5 6 8 ## 3527 265 105 25 6 3 1 # Om na te gaan wel spectrum 8 matches heeft which(table(id_csf_fil$spectrumID) == 8) ## scan=2054 file=3445 ## 1584 # Verdere verdieping in de data csf_8m &lt;- id_csf_fil[id_csf_fil$spectrumID == &quot;scan=2054 file=3445&quot;, ] %&gt;% as.data.frame() csf_8m[, c(&quot;modName&quot;, &quot;modLocation&quot;)] ## modName modLocation ## 1 Carbamidomethyl 16 ## 2 Oxidation 20 ## 3 Carbamidomethyl 16 ## 4 Oxidation 19 ## 5 Carbamidomethyl 16 ## 6 Oxidation 20 ## 7 Carbamidomethyl 16 ## 8 Oxidation 19 # Reduceren van de PSMs id_csf_fil &lt;- reducePSMs(id_csf_fil, id_csf_fil$spectrumID) table(table(id_csf_fil$spectrumID)) ## ## 1 ## 3932 In de gefilterde data zijn er nog steeds meerdere PSMs die aan een enkel spectrum gekoppeld zijn, het spectrum met 10 matches is er wel uit gefilterd. Er is ook nog een spectrum met 8 matches, met which(table(id_csf_fil$spectrumID) == 8) is achterhaald dat dit “scan=2054 file=3445” is. Deze PSMs van dit spectrum verschillen in type modificatie en modificatie locatie, 4 van de PSMs hebben een Carbamidomethyl modificatie en vier van de PSMs hebben een Oxidatie modificatie. De locatie van de Carbamidomethyl modificatie is voor alle vier de PSMs hetzelfde, namelijk 16. De locatie van de Oxidatie modificatie verschilt tussen de PSMs, twee modificaties zijn op locatie 19 en twee op locatie 20. Voor de rest is alle data van de PSMs gelijk. Voordat de ruwe data en de identificatie data samengevoegd kunnen worden moet het aantal PSMs nog een keer gereduceerd worden, zodat er alleen unieke PSMs overblijven, dit wordt uitgevoerd met reducePSMs. Als je daarna nog een keer table(table(id_csf_fil$spectrumID)) gebruikt, krijg je alleen spectrums met 1 match. com_csf &lt;- joinSpectraData(sp_csf, id_csf_fil, by.x = &quot;spectrumId&quot;, by.y = &quot;spectrumID&quot;) com_csf1 &lt;- filterMsLevel(com_csf, 1) unique(any(is.na(com_csf1$sequence))) ## logical(0) com_csf2 &lt;- filterMsLevel(com_csf, 2) unique(any(is.na(com_csf2$sequence))) ## [1] FALSE Met joinSpectraData worden de objecten sp_csf en id_csf_fil samengevoegd. Om te controleren of er geen identificatie data is toegevoegd aan MS1 scans wordt er gefilterd op MS1 scans en daarna gekeken over er sequence data is. Dit geeft logical(0), dit komt omdat PXD018226 geen MS1 data bevat. Wanneer hetzelfde gedaan wordt voor MS2, zie je dat de identificatie data aan 100% van de MS2 spectra is toegevoegd, alles geeft namelijk FALSE. com_csf &lt;- countIdentifications(com_csf) De functie countIdentifications(com_csf) geeft de error: ‘Error in as.vector(x, mode): coercing an Atomiclist object to an atomic vector is supported only for object with top-level elements of length &lt;= 1’. Dit komt doordat veel elementen in id_csf_fil een lijst hebben, namelijk sequence, peptideRef, end, DatabaseAccess, DBseqLength, DatabaseSeq, DatabaseDescription, modPeptideRef, modName en modMass. Ik heb geprobeerd dit op te lossen met de unlist() functie, maar deze werkt alleen op de top level waardoor heel veel variabelen en data verloren gaan. Ik heb het ook apart geprobeerd op te lossen met unlist(id_csf_fil@listData[[\"sequence\"]]) dit heeft wel de unlistData uit de lijst van de sequence gehaald. 4.6 Links Massa spectrometry website voor R: click here for the link PRIDE PXD008990: click here for the link Pubmed artikel: click here for the link PRIDE PXD018226: click here for the link Pubmed artikel: click here for the link Spectra tutorial: click here for the link MSnbase tutorial: click here for the link Spectra package tutorial: click here for the link "],["r-seurat-guided-clustering-tutorial.html", "5 R Seurat: Guided Clustering Tutorial 5.1 Uitvoering met voorbeeld data 5.2 Uitvoering met CSF1R-related disorder 5.3 Links", " 5 R Seurat: Guided Clustering Tutorial 5.1 Uitvoering met voorbeeld data pbmc.data &lt;- Read10X(data.dir = &quot;seurat_data/ruwe data/filtered_gene_bc_matrices/hg19/&quot;) # Initialize the Seurat object with the raw (non-normalized data). pbmc &lt;- CreateSeuratObject(counts = pbmc.data, project = &quot;pbmc3k&quot;, min.cells = 3, min.features = 200) pbmc ## An object of class Seurat ## 13714 features across 2700 samples within 1 assay ## Active assay: RNA (13714 features, 0 variable features) ## 1 layer present: counts # Lets examine a few genes in the first thirty cells pbmc.data[c(&quot;CD3D&quot;, &quot;TCL1A&quot;, &quot;MS4A1&quot;), 1:30] ## 3 x 30 sparse Matrix of class &quot;dgCMatrix&quot; ## ## CD3D 4 . 10 . . 1 2 3 1 . . 2 7 1 . . 1 3 . 2 3 . . . . . 3 4 1 5 ## TCL1A . . . . . . . . 1 . . . . . . . . . . . . 1 . . . . . . . . ## MS4A1 . 6 . . . . . . 1 1 1 . . . . . . . . . 36 1 2 . . 2 . . . . De . waardes in de matrix vertegenwoordigen 0 waardes, oftewel geen moleculen gedetecteerd. 5.1.1 Pre-processing workflow Met pre-processing worden de cellen met een lage kwaliteit eruit gefilterd. nFeature is het aantal genen en nCount is het aantal moleculen. Een cel met een lage kwaliteit heeft een laag aantal genen en/of moleculen. # % MT reads pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) # Visualize QC metrics as a violin plot VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) # Feature scatter plot1 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) plot2 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) + geom_smooth(method = &#39;lm&#39;) plot1 + plot2 # Filtering of cells pbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 2500 &amp; percent.mt &lt; 5) # Normalizing the data pbmc &lt;- NormalizeData(pbmc) Met PercentageFeatureSet kan het percentage van alle counts die bij een bepaald gen van de cel horen berekend worden. Met de bovenstaande code wordt het percentage van reads/counts berekend die behoren tot het mitochondriaal genoom. Met pattern = \"^MT-\" wordt er gezocht naar alle genen die starten met MT. VlnPlot maakt een violin plot van single cell data. Met features wordt aangegeven welk kenmerk geplot moet worden. FeatureScatter maakt een scatterplot van twee kenmerken (features), de cellen zijn gekleurd op basis van hun identiteits klasse. De pearson correlation tussen de twee kenmerken is boven aan het plot weergeven. Op basis van de visualisatie worden de cellen gefilterd die een unique feature counts over 2500 of minder dan 200 hebben en die meer dan 5% mitochondrial counts hebben. 5.1.2 Identification of highly variable features In dit deel wordt er een deel van de kenmerken verzameld welk een hoge cell-to-cell variatie hebben in de dataset, dit houdt in dat ze hoog tot expressie komen in sommige cellen en laag in andere cellen. pbmc &lt;- FindVariableFeatures(pbmc, selection.method = &quot;vst&quot;, nfeatures = 2000) # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(pbmc), 10) # plot variable features with and without labels plot1 &lt;- VariableFeaturePlot(pbmc) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE) plot1 + plot2 FindVariableFeatures identificeerd kenmerken die outliers zijn op een mean variability plot. Met selection.method geef je aan hoe de top variabelen kenmerken gekozen moeten worden. “vst” zet eerst een lijn op van de relatie tussen de log(variance) en de log(mean) en standaardiseerd de feature values door gebruik te maken van het waargenomen gemiddelde en de verwachte variance. 5.1.3 Perform linear dimensional reduction all.genes &lt;- rownames(pbmc) pbmc &lt;- ScaleData(pbmc, features = all.genes) ## Centering and scaling data matrix De ScaleData functie verschuift de expressie van elk gen, zodat de gemiddelde expressie over de cellen 0 is en schaalt de expressie van elk gen, zodat de variantie tussen cellen 1 is. # Perform a PCA dimensionality reduction pbmc &lt;- RunPCA(pbmc, features = VariableFeatures(object = pbmc)) # Visualizing the PCA VizDimLoadings(pbmc, dims = 1:2, reduction = &quot;pca&quot;) DimPlot(pbmc, reduction = &quot;pca&quot;) + NoLegend() DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE) DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE) RunPCA levert een lijst met genen met de meest positieve en negatieve ladingen, die modules van genen vertegenwoordigen die correlatie of anticorrelatie vertonen tussen afzonderlijke cellen in de dataset. Een positieve lading betekent dat het gen positief correleert met het component, oftewel, een hogere expressie van dit gen draagt bij aan een hogere waarde van het component. Een negatieve lading houdt in dat een hogere expressie van dit gen bijdraagt aan een lagere waarde van die component. De DimHeatmap functie visualiseert de genen die het meest bijdragen aan de gekozen principal component (PC). De rijen vertegenwoordigen de genen die bijdrage aan de eerste dimensie (PC1), de kolommen vertegenwoordigen de 500 cellen (cells = 500) en de kleurintensiteit in de heatmap geeft de bijdrage van een gen aan de eerste dimensie van de dimensionale reductie aan. Als bepaalde genen felgekleurde vakjes hebben, betekent dit dat deze genen sterk bijdragen aan de variatie in de data die door de eerste dimensie wordt vastgelegd. Het argument balance = TRUE zorgt ervoor dat de kleurintensiteit over de heatmap gebalanceerd wordt. 5.1.3.1 Determine the dimensionality of the dataset ElbowPlot(pbmc) Het doel van de ElbowPlot functie is om te bepalen hoeveel principal components je moet behouden. Het identificeert het punt waar het toevoegen van meer componenten niet veel extra variatie verklaart. De elbow is het punt waar de verklaarde variatie sterk begint af te nemen en de curve begint af te vlakken. In het bovenstaande voorbeeld is de elbow zichtbaar rond PC9-10, wat erop wijst dat het merendeel van het echte signaal wordt opgevangen op de eerste tien pc’s. 5.1.4 Cluster the cells &amp; UMAP pbmc &lt;- FindNeighbors(pbmc, dims = 1:10) pbmc &lt;- FindClusters(pbmc, resolution = 0.5) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 2638 ## Number of edges: 95927 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8728 ## Number of communities: 9 ## Elapsed time: 0 seconds pbmc &lt;- RunUMAP(pbmc, dims = 1:10) DimPlot(pbmc, reduction = &quot;umap&quot;, label = TRUE) De FindNeighbors functie berekent de afstanden tussen cellen in de lagere dimensionale ruimte (zoals PCA). Dit wordt uitgevoerd op de eerste 10 PC’s zoals bepaald met de ElbowPlot. De FindClusters functie wordt gebruikt om cellen te groeperen in clustergroepen op basis van hun genexpressieprofielen. 5.1.5 Finding differentially expressed features ## For a (much!) faster implementation of the Wilcoxon Rank Sum Test, ## (default method for FindMarkers) please install the presto package ## -------------------------------------------- ## install.packages(&#39;devtools&#39;) ## devtools::install_github(&#39;immunogenomics/presto&#39;) ## -------------------------------------------- ## After installation of presto, Seurat will automatically use the more ## efficient implementation (no further action necessary). ## This message will be shown once per session ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## IL32 2.892340e-90 1.3070772 0.947 0.465 3.966555e-86 ## LTB 1.060121e-86 1.3312674 0.981 0.643 1.453850e-82 ## CD3D 8.794641e-71 1.0597620 0.922 0.432 1.206097e-66 ## IL7R 3.516098e-68 1.4377848 0.750 0.326 4.821977e-64 ## LDHB 1.642480e-67 0.9911924 0.954 0.614 2.252497e-63 ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## FCGR3A 8.246578e-205 6.794969 0.975 0.040 1.130936e-200 ## IFITM3 1.677613e-195 6.192558 0.975 0.049 2.300678e-191 ## CFD 2.401156e-193 6.015172 0.938 0.038 3.292945e-189 ## CD68 2.900384e-191 5.530330 0.926 0.035 3.977587e-187 ## RP11-290F20.3 2.513244e-186 6.297999 0.840 0.017 3.446663e-182 ## Calculating cluster 0 ## Calculating cluster 1 ## Calculating cluster 2 ## Calculating cluster 3 ## Calculating cluster 4 ## Calculating cluster 5 ## Calculating cluster 6 ## Calculating cluster 7 ## Calculating cluster 8 ## # A tibble: 7,019 × 7 ## # Groups: cluster [9] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 3.75e-112 1.21 0.912 0.592 5.14e-108 0 LDHB ## 2 9.57e- 88 2.40 0.447 0.108 1.31e- 83 0 CCR7 ## 3 1.15e- 76 1.06 0.845 0.406 1.58e- 72 0 CD3D ## 4 1.12e- 54 1.04 0.731 0.4 1.54e- 50 0 CD3E ## 5 1.35e- 51 2.14 0.342 0.103 1.86e- 47 0 LEF1 ## 6 1.94e- 47 1.20 0.629 0.359 2.66e- 43 0 NOSIP ## 7 2.81e- 44 1.53 0.443 0.185 3.85e- 40 0 PIK3IP1 ## 8 6.27e- 43 1.99 0.33 0.112 8.60e- 39 0 PRKCQ-AS1 ## 9 1.16e- 40 2.70 0.2 0.04 1.59e- 36 0 FHIT ## 10 1.34e- 34 1.96 0.268 0.087 1.84e- 30 0 MAL ## # ℹ 7,009 more rows VlnPlot(pbmc, features = c(&quot;MS4A1&quot;, &quot;CD79A&quot;)) # you can plot raw counts as well VlnPlot(pbmc, features = c(&quot;NKG7&quot;, &quot;PF4&quot;), slot = &quot;counts&quot;, log = TRUE) ## Warning: The `slot` argument of `VlnPlot()` is deprecated as of ## Seurat 5.0.0. ## ℹ Please use the `layer` argument instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where ## this warning was generated. FeaturePlot(pbmc, features = c(&quot;MS4A1&quot;, &quot;GNLY&quot;, &quot;CD3E&quot;, &quot;CD14&quot;, &quot;FCER1A&quot;, &quot;FCGR3A&quot;, &quot;LYZ&quot;, &quot;PPBP&quot;, &quot;CD8A&quot;)) pbmc.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) %&gt;% slice_head(n = 10) %&gt;% ungroup() -&gt; top10 DoHeatmap(pbmc, features = top10$gene) + NoLegend() De code VlnPlot(pbmc, features = c(\"MS4A1\", \"CD79A\")) genereert een violin plot die laat zien hoe de genexpressie van “MS4A1” en “CD79A” varieert over de cellen in pbmc. Met slot = \"counts\" geeft aan dat de ruwe telwaardes worden gebruikt voor de visualisatie. FeaturePlot kleurt single cellen in een dimensional reduction plot volgens een feature (kenmerk), in dit geval volgens de gen naam. Met de DoHeatmap functie en de voorgaande filter worden de top 10 genen per cluster weergeven. De balk helemaal bovenaan weergeeft het cluster nummer, welk ook terug te zien zijn in de UMAP. 5.1.6 Assigning cell type identity to clusters new.cluster.ids &lt;- c(&quot;Naive CD4 T&quot;, &quot;CD14+ Mono&quot;, &quot;Memory CD4 T&quot;, &quot;B&quot;, &quot;CD8 T&quot;, &quot;FCGR3A+ Mono&quot;, &quot;NK&quot;, &quot;DC&quot;, &quot;Platelet&quot;) names(new.cluster.ids) &lt;- levels(pbmc) pbmc &lt;- RenameIdents(pbmc, new.cluster.ids) DimPlot(pbmc, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5) + NoLegend() plot &lt;- DimPlot(pbmc, reduction = &quot;umap&quot;, label = TRUE, label.size = 4.5) + xlab(&quot;UMAP 1&quot;) + ylab(&quot;UMAP 2&quot;) + theme(axis.title = element_text(size = 14), legend.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 6))) plot 5.2 Uitvoering met CSF1R-related disorder Bij CSF1R-RD is er sprake van mutaties in de colony-stimulating factor-1 receptor CSF1R gen (microglia) die voornamelijk een effect hebben op de witte stof van het brein. CSF1R is essentieel voor de proliferatie, fagocytose, motiliteit en overleving van microglia. Met single nucleaire RNA-sequencing (snRNAseq) zijn twee microglia celtoestanden geïdentificeerd die geassocieerd worden met de CSF1R-RD, dit zijn de lipid-laden en de inflammatory toestanden. De verkregen data set bevat de resultaten van de snRNAseq van de microglia. # Pad naar rds file ad_file &lt;- &quot;../../Downloads/f9bca543-f82a-4863-bd62-b270b634ea10.rds&quot; # Inlezen van het bestand naar een Seurat object alzheimer &lt;- readRDS(ad_file) # Kijk tot welke class object alzheimer behoort class(alzheimer) ## [1] &quot;Seurat&quot; ## attr(,&quot;package&quot;) ## [1] &quot;SeuratObject&quot; Na het inlezen met readRDS is het bestand al een seurat object, de CreateSeuratObject functie hoeft daarom niet meer toegepast te worden. 5.2.1 Pre-processing workflow # Visualiseer QC metrics als een violin plot VlnPlot(alzheimer, features = c(&quot;nFeaturess_RNA&quot;, &quot;nCounts_RNA&quot;, &quot;pct_counts_mt&quot;), ncol = 3) # Feature scatter plot1 &lt;- FeatureScatter(alzheimer, feature1 = &quot;nCounts_RNA&quot;, feature2 = &quot;pct_counts_mt&quot;) plot2 &lt;- FeatureScatter(alzheimer, feature1 = &quot;nCounts_RNA&quot;, feature2 = &quot;nFeaturess_RNA&quot;) + geom_smooth(method = &#39;lm&#39; ) plot1 + plot2 alzheimer &lt;- subset(alzheimer, subset = nFeaturess_RNA &gt; 200 &amp; nFeaturess_RNA &lt; 3500 &amp; pct_counts_mt &lt; 5) # Normaliseer de data alzheimer &lt;- NormalizeData(alzheimer) Het Seurat object bevat al een pct_counts_mt dus dit hoeft niet meer berekend te worden met PercentageFeatureSet. Het object is gefilterd voor nFeaturess boven de 200 en onder de 3500, dit omdat bij 3500 ongeveer de stippen niet meer langs de lijn gaan. 5.2.2 Identification of highly variable features alzheimer &lt;- FindVariableFeatures(alzheimer, selection.method = &quot;vst&quot;, nfeatures = 2000) # Identificeer de 10 meest highly variable genes top10 &lt;- head(VariableFeatures(alzheimer), 10) # plot variable features met labels plot1 &lt;- VariableFeaturePlot(alzheimer) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE) plot2 In het bovenstaande plot staan de genen aangegeven die de hoogste variatie hebben, de genen zijn aangegeven met hun Ensembl ID. 5.2.3 Perform linear dimensional reduction all.genes &lt;- rownames(alzheimer) alzheimer &lt;- ScaleData(alzheimer, features = all.genes) ## Centering and scaling data matrix De ScaleData functie verschuift de expressie van elk gen, zodat de gemiddelde expressie over de cellen 0 is en schaalt de expressie van elk gen, zodat de variantie tussen cellen 1 is. # Voer een PCA dimensionality reduction uit alzheimer &lt;- RunPCA(alzheimer, features = VariableFeatures(object = alzheimer)) # Visualiseer the PCA VizDimLoadings(alzheimer, dims = 1:2, reduction = &quot;pca&quot;) DimPlot(alzheimer, reduction = &quot;pca&quot;) + NoLegend() DimHeatmap(alzheimer, dims = 1, cells = 200, balanced = TRUE) DimHeatmap(alzheimer, dims = 1:9, cells = 200, balanced = TRUE) 5.2.3.1 Determine the dimensionality of the dataset ElbowPlot(alzheimer, ndims = 30) Met ndims kan het aantal dimensions die geplot worden voor standaarddeviatie worden bepaald. Aangezien de Elbow voorbij 20 zat, kan niet de default gebruikt worden die 20 demensions weergeeft en vandaar is het naar 30 gezet. De elbow zit ongeveer bij 22. 5.2.4 Cluster the cells &amp; UMAP alzheimer &lt;- FindNeighbors(alzheimer, dims = 1:20) alzheimer &lt;- FindClusters(alzheimer, resolution = 0.5) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 1427 ## Number of edges: 54379 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8777 ## Number of communities: 7 ## Elapsed time: 0 seconds alzheimer &lt;- RunUMAP(alzheimer, dims = 1:20) DimPlot(alzheimer, reduction = &quot;umap&quot;, label = TRUE) 5.2.5 Finding differentially expressed features # vind markers voor elk cluster in vergelijking met alle overige cellen, reporteer alleen de positieve alzheimer.markers &lt;- FindAllMarkers(alzheimer, only.pos = TRUE) alzheimer.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) ## # A tibble: 7,780 × 7 ## # Groups: cluster [7] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 3.33e-62 3.15 0.463 0.083 2.05e-57 0 ENSG00000249867 ## 2 1.07e-53 2.57 0.593 0.215 6.55e-49 0 ENSG00000146090 ## 3 2.26e-45 1.80 0.739 0.481 1.39e-40 0 ENSG00000067798 ## 4 2.85e-45 1.29 0.893 0.79 1.75e-40 0 ENSG00000073849 ## 5 1.64e-41 2.15 0.665 0.393 1.01e-36 0 ENSG00000101463 ## 6 1.67e-37 3.40 0.27 0.041 1.02e-32 0 ENSG00000273409 ## 7 7.50e-37 3.80 0.326 0.074 4.61e-32 0 ENSG00000198010 ## 8 9.69e-36 1.45 0.757 0.473 5.96e-31 0 ENSG00000184005 ## 9 3.25e-34 5.21 0.178 0.012 2.00e-29 0 ENSG00000182836 ## 10 1.30e-30 1.05 0.84 0.717 7.99e-26 0 ENSG00000149177 ## # ℹ 7,770 more rows VlnPlot(alzheimer, features = c(&quot;ENSG00000073849&quot;, &quot;ENSG00000170677&quot;, &quot;ENSG00000146090&quot;, &quot;ENSG00000136235&quot;, &quot;ENSG00000111913&quot;)) # you can plot raw counts as well VlnPlot(alzheimer, features = c(&quot;ENSG00000073849&quot;, &quot;ENSG00000170677&quot;), layer = &quot;counts&quot;, log = TRUE) FeaturePlot(alzheimer, features = c(&quot;ENSG00000073849&quot;, &quot;ENSG00000170677&quot;, &quot;ENSG00000146090&quot;, &quot;ENSG00000136235&quot;, &quot;ENSG00000111913&quot;)) alzheimer.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) %&gt;% slice_head(n = 5) %&gt;% ungroup() -&gt; top5 DoHeatmap(alzheimer, features = top5$gene) + NoLegend() De code VlnPlot(pbmc, features = c()) genereert een violin plot die laat zien hoe de genexpressie van “ENSG00000073849”, “ENSG00000170677”, “ENSG00000146090”, “ENSG00000136235” en “ENSG00000111913” variëren over de cellen in alzheimer. Zoals je kan zien is ENSG0000073849 in alle clusters aanwezig. ENSG000000136235 komt voornamelijk in cluster 1 tot expressie en ENSG00000111913 komt voornamelijk in cluster 5 tot expressie, dit komt overeen met de heatmap. Met layer = \"counts\" geeft aan dat de ruwe telwaardes worden gebruikt voor de visualisatie. FeaturePlot kleurt single cellen in een dimensional reduction plot volgens een feature (kenmerk), in dit geval volgens de gen naam. Met de DoHeatmap functie en de voorgaande filter worden de top 5 genen per cluster weergeven. De balk helemaal bovenaan weergeeft het cluster nummer, welk ook terug te zien zijn in de UMAP. 5.3 Links Seurat tutorial: click here for the link Dataset Alzheimer: click here for the link Artikel: click here for the link Youtube tutorial analysis: click here for the link "],["guerrilla-analytics-framework.html", "6 Guerrilla Analytics framework 6.1 Daur2 6.2 Workflows", " 6 Guerrilla Analytics framework 6.1 Daur2 library(fs) fs::dir_tree(here::here(&quot;daur2&quot;)) ## /Users/cheryloortwijn/dsfb2/dsfb2_workflows_portfolio/daur2 ## ├── airway_rnaseq ## │ ├── README.txt ## │ ├── airway_rnaseq.Rmd ## │ ├── data ## │ │ ├── bam ## │ │ ├── count ## │ │ ├── fastqc ## │ │ └── genome_index ## │ ├── raw_data ## │ │ ├── GRCh38.primary_assembly.genome.fa.gz ## │ │ ├── rna_rawdata1.txt ## │ │ └── sample_data ## │ └── verslag ## ├── eindopdracht_daur2 ## │ ├── README.txt ## │ ├── data ## │ │ ├── bam ## │ │ ├── fastqc ## │ │ └── read_counts_OC1.rds ## │ ├── eindopdracht.Rmd ## │ └── raw_data ## │ ├── fastq ## │ └── sample_data.csv ## ├── ipsc_rnaseq ## │ ├── README.txt ## │ ├── data ## │ │ ├── bam ## │ │ ├── counts ## │ │ └── fastqc ## │ ├── ipsc_rnaseq.Rmd ## │ └── raw data ## │ ├── rawdata_ipsc.fastq ## │ ├── rawdata_ipsc1.fastq ## │ └── sample_data.txt ## ├── metagenomics_formative ## │ ├── data ## │ │ ├── bracken ## │ │ ├── fastqc ## │ │ └── kraken2 ## │ ├── metagenomics_formative.Rmd ## │ └── ruw_data ## │ └── fastq ## └── metagenomics_reader ## ├── README.txt ## ├── data ## │ ├── bracken ## │ │ └── mock1.bracken ## │ ├── fastqc ## │ └── kraken2 ## │ └── mock1 ## ├── metagenomics_reader.Rmd ## └── raw_data ## ├── HU1_MOCK1_L001_R1_001.fastq.gz ## ├── HU_waternet_MOCK1_composition.csv ## └── minikraken2_v2_8GB_201904_UPDATE 6.2 Workflows Workflows portfolio: fs::dir_tree(here::here(&quot;../dsfb2_workflows_portfolio&quot;)) ## /Users/cheryloortwijn/dsfb2/dsfb2_workflows_portfolio/../dsfb2_workflows_portfolio ## ├── 01_CV.Rmd ## ├── 02_Extra_tijd.Rmd ## ├── 03_opdracht_vrije_tijd.Rmd ## ├── 04_vrije_tijd_seurat.Rmd ## ├── 05_opdracht_3.Rmd ## ├── 06_opdracht_4.1.Rmd ## ├── 07_opdracht_4.2.Rmd ## ├── 08_package.Rmd ## ├── 09_opdracht_7.Rmd ## ├── 10_opdracht_9.Rmd ## ├── MS-data ## │ ├── MS_voorbeeld.Rmd ## │ ├── README.md ## │ ├── data ## │ └── raw_data ## ├── Rmd ## │ ├── Opdracht_4.2.Rmd ## │ └── anoniem-vrouw-stichting-Sparrow.jpg ## ├── _book ## │ ├── 404.html ## │ ├── Rmd ## │ │ └── anoniem-vrouw-stichting-Sparrow.jpg ## │ ├── _main_files ## │ │ └── figure-html ## │ │ ├── 3 bestanden pd-1.png ## │ │ ├── 3D plot pd-1.png ## │ │ ├── 3D plot-1.png ## │ │ ├── Comparing spectra vb-1.png ## │ │ ├── Comparing spectra vb-2.png ## │ │ ├── Comparing spectra-1.png ## │ │ ├── Comparing spectra-2.png ## │ │ ├── DE visualisatie ad-1.png ## │ │ ├── DE visualisatie ad-2.png ## │ │ ├── DE visualisatie ad-3.png ## │ │ ├── DE visualisatie ad-4.png ## │ │ ├── DE visualisatie-1.png ## │ │ ├── DE visualisatie-2.png ## │ │ ├── DE visualisatie-3.png ## │ │ ├── DE visualisatie-4.png ## │ │ ├── QC and selecting cells ad-1.png ## │ │ ├── QC and selecting cells ad-2.png ## │ │ ├── QC and selecting cells-1.png ## │ │ ├── QC and selecting cells-2.png ## │ │ ├── cell type-1.png ## │ │ ├── cell type-2.png ## │ │ ├── clustering ad-1.png ## │ │ ├── clustering-1.png ## │ │ ├── comparing spectra 2 vb-1.png ## │ │ ├── comparing spectra 2 vb-2.png ## │ │ ├── comparing spectra 2 vb-3.png ## │ │ ├── dimensionality ad-1.png ## │ │ ├── dimensionality-1.png ## │ │ ├── filtered visualisation pd-1.png ## │ │ ├── filtered visualisation pd-2.png ## │ │ ├── filtering data-1.png ## │ │ ├── filtering data-2.png ## │ │ ├── linear dimensional reduction ad-1.png ## │ │ ├── linear dimensional reduction ad-2.png ## │ │ ├── linear dimensional reduction ad-3.png ## │ │ ├── linear dimensional reduction ad-4.png ## │ │ ├── linear dimensional reduction-1.png ## │ │ ├── linear dimensional reduction-2.png ## │ │ ├── linear dimensional reduction-3.png ## │ │ ├── linear dimensional reduction-4.png ## │ │ ├── peptide-spectrum matches-1.png ## │ │ ├── peptide-spectrum matches-2.png ## │ │ ├── plot eiwit lengte en peptide aantal-1.png ## │ │ ├── plot eiwit lengte en peptide aantal-2.png ## │ │ ├── plot retentietijd en m ## │ │ │ └── z-1.png ## │ │ ├── plot rtime en m ## │ │ │ └── z pd-1.png ## │ │ ├── plotDensity quality control-1.png ## │ │ ├── plotDensity quality control-2.png ## │ │ ├── total ion chromatogram-1.png ## │ │ ├── unnamed-chunk-10-1.png ## │ │ ├── unnamed-chunk-2-1.png ## │ │ ├── unnamed-chunk-3-1.png ## │ │ ├── unnamed-chunk-4-1.png ## │ │ ├── unnamed-chunk-8-1.png ## │ │ ├── unnamed-chunk-9-1.png ## │ │ ├── variable features ad-1.png ## │ │ ├── variable features-1.png ## │ │ ├── visualisatie MS1 en MS2 vb-1.png ## │ │ ├── visualisatie MS1 en MS2 vb-2.png ## │ │ ├── visualisatie MS2 pd-1.png ## │ │ ├── visualisatie MS2 vb-1.png ## │ │ ├── visualisatie chromatogram pd-1.png ## │ │ ├── visualisatie chromatogram vb-1.png ## │ │ ├── visualitatie MS1 en MS2 csf-1.png ## │ │ ├── visualitatie MS1 en MS2 pd-1.png ## │ │ └── visualitatie MS1 en MS2 pd-2.png ## │ ├── c.elegans-plate-experiment.html ## │ ├── contactgegevens.html ## │ ├── create-a-package.html ## │ ├── curriculum-vitae.html ## │ ├── cv.html ## │ ├── ecdc-covid-19-cases-data-parameterization.html ## │ ├── guerrilla-analytics-framework.html ## │ ├── index.html ## │ ├── libs ## │ │ ├── anchor-sections-1.1.0 ## │ │ │ ├── anchor-sections-hash.css ## │ │ │ ├── anchor-sections.css ## │ │ │ └── anchor-sections.js ## │ │ ├── bsTable-3.3.7 ## │ │ │ ├── bootstrapTable.js ## │ │ │ └── bootstrapTable.min.css ## │ │ ├── crosstalk-1.2.1 ## │ │ │ ├── css ## │ │ │ │ └── crosstalk.min.css ## │ │ │ └── js ## │ │ │ └── crosstalk.min.js ## │ │ ├── datatables-binding-0.33 ## │ │ │ └── datatables.js ## │ │ ├── datatables-css-0.0.0 ## │ │ │ └── datatables-crosstalk.css ## │ │ ├── dt-core-1.13.6 ## │ │ │ ├── css ## │ │ │ │ ├── jquery.dataTables.extra.css ## │ │ │ │ └── jquery.dataTables.min.css ## │ │ │ └── js ## │ │ │ └── jquery.dataTables.min.js ## │ │ ├── gitbook-2.6.7 ## │ │ │ ├── css ## │ │ │ │ ├── fontawesome ## │ │ │ │ │ └── fontawesome-webfont.ttf ## │ │ │ │ ├── plugin-bookdown.css ## │ │ │ │ ├── plugin-clipboard.css ## │ │ │ │ ├── plugin-fontsettings.css ## │ │ │ │ ├── plugin-highlight.css ## │ │ │ │ ├── plugin-search.css ## │ │ │ │ ├── plugin-table.css ## │ │ │ │ └── style.css ## │ │ │ └── js ## │ │ │ ├── app.min.js ## │ │ │ ├── clipboard.min.js ## │ │ │ ├── jquery.highlight.js ## │ │ │ ├── plugin-bookdown.js ## │ │ │ ├── plugin-clipboard.js ## │ │ │ ├── plugin-fontsettings.js ## │ │ │ ├── plugin-search.js ## │ │ │ └── plugin-sharing.js ## │ │ ├── htmltools-fill-0.5.8.1 ## │ │ │ └── fill.css ## │ │ ├── htmlwidgets-1.6.4 ## │ │ │ └── htmlwidgets.js ## │ │ ├── jquery-3.6.0 ## │ │ │ └── jquery-3.6.0.min.js ## │ │ ├── kePrint-0.0.1 ## │ │ │ └── kePrint.js ## │ │ ├── lightable-0.0.1 ## │ │ │ └── lightable.css ## │ │ ├── plotly-binding-4.10.4 ## │ │ │ └── plotly.js ## │ │ ├── plotly-htmlwidgets-css-2.11.1 ## │ │ │ └── plotly-htmlwidgets.css ## │ │ ├── plotly-main-2.11.1 ## │ │ │ └── plotly-latest.min.js ## │ │ └── typedarray-0.1 ## │ │ └── typedarray.min.js ## │ ├── links-1.html ## │ ├── looking-ahead.html ## │ ├── massa-spectrometrie---opdracht-vrije-tijd.html ## │ ├── massa-spectrometrie-verdieping.html ## │ ├── opdracht-1.html ## │ ├── opdracht-3-guerrilla-analytics-framework.html ## │ ├── opdracht-4.2-deel-2.html ## │ ├── opdracht-4.html ## │ ├── open-peer-review-reproducibility.html ## │ ├── opleidingen.html ## │ ├── perform-linear-dimensional-reduction.html ## │ ├── projecticum-antimicrobiële-resistentie-amr.html ## │ ├── r-for-mass-spectrometry.html ## │ ├── r-seurat-guided-clustering-tutorial.html ## │ ├── search_index.json ## │ ├── vaardigheden.html ## │ ├── vrije-tijd.html ## │ └── werkervaring.html ## ├── _bookdown_files ## ├── _main.Rmd ## ├── _main_cache ## │ └── html ## │ ├── __packages ## │ ├── unnamed-chunk-12_b353983f6dcd7ef17f9419e6e9a39711.RData ## │ ├── unnamed-chunk-12_b353983f6dcd7ef17f9419e6e9a39711.rdb ## │ ├── unnamed-chunk-12_b353983f6dcd7ef17f9419e6e9a39711.rdx ## │ ├── unnamed-chunk-13_b9f3bbbe4ad72693616a1dd42dad02fd.RData ## │ ├── unnamed-chunk-13_b9f3bbbe4ad72693616a1dd42dad02fd.rdb ## │ ├── unnamed-chunk-13_b9f3bbbe4ad72693616a1dd42dad02fd.rdx ## │ ├── unnamed-chunk-14_3c4d861096a32f7c2f2a3289c4d01c53.RData ## │ ├── unnamed-chunk-14_3c4d861096a32f7c2f2a3289c4d01c53.rdb ## │ ├── unnamed-chunk-14_3c4d861096a32f7c2f2a3289c4d01c53.rdx ## │ ├── unnamed-chunk-15_8e14c1b3ade978dc5e448928d46f6a64.RData ## │ ├── unnamed-chunk-15_8e14c1b3ade978dc5e448928d46f6a64.rdb ## │ ├── unnamed-chunk-15_8e14c1b3ade978dc5e448928d46f6a64.rdx ## │ ├── unnamed-chunk-3_f531eed8bebb09047ac2b8875bc59e9c.RData ## │ ├── unnamed-chunk-3_f531eed8bebb09047ac2b8875bc59e9c.rdb ## │ ├── unnamed-chunk-3_f531eed8bebb09047ac2b8875bc59e9c.rdx ## │ ├── unnamed-chunk-4_b66e74fb307de59ae9d6e3d0b2050160.RData ## │ ├── unnamed-chunk-4_b66e74fb307de59ae9d6e3d0b2050160.rdb ## │ ├── unnamed-chunk-4_b66e74fb307de59ae9d6e3d0b2050160.rdx ## │ ├── unnamed-chunk-5_144ed37d84acf96578fea38552fb34c4.RData ## │ ├── unnamed-chunk-5_144ed37d84acf96578fea38552fb34c4.rdb ## │ ├── unnamed-chunk-5_144ed37d84acf96578fea38552fb34c4.rdx ## │ ├── unnamed-chunk-6_a453c929a909a1d940409d219f75c7b7.RData ## │ ├── unnamed-chunk-6_a453c929a909a1d940409d219f75c7b7.rdb ## │ └── unnamed-chunk-6_a453c929a909a1d940409d219f75c7b7.rdx ## ├── _main_files ## │ └── figure-html ## │ ├── 3 bestanden pd-1.png ## │ ├── 3D plot pd-1.png ## │ ├── 3D plot-1.png ## │ ├── Comparing spectra vb-1.png ## │ ├── Comparing spectra vb-2.png ## │ ├── Comparing spectra-1.png ## │ ├── Comparing spectra-2.png ## │ ├── DE visualisatie ad-1.png ## │ ├── DE visualisatie ad-2.png ## │ ├── DE visualisatie ad-3.png ## │ ├── DE visualisatie ad-4.png ## │ ├── DE visualisatie-1.png ## │ ├── DE visualisatie-2.png ## │ ├── DE visualisatie-3.png ## │ ├── DE visualisatie-4.png ## │ ├── QC and selecting cells ad-1.png ## │ ├── QC and selecting cells ad-2.png ## │ ├── QC and selecting cells-1.png ## │ ├── QC and selecting cells-2.png ## │ ├── cell type-1.png ## │ ├── cell type-2.png ## │ ├── clustering ad-1.png ## │ ├── clustering-1.png ## │ ├── comparing spectra 2 vb-1.png ## │ ├── comparing spectra 2 vb-2.png ## │ ├── comparing spectra 2 vb-3.png ## │ ├── dimensionality ad-1.png ## │ ├── dimensionality-1.png ## │ ├── filtered visualisation pd-1.png ## │ ├── filtered visualisation pd-2.png ## │ ├── filtering data-1.png ## │ ├── filtering data-2.png ## │ ├── linear dimensional reduction ad-1.png ## │ ├── linear dimensional reduction ad-2.png ## │ ├── linear dimensional reduction ad-3.png ## │ ├── linear dimensional reduction ad-4.png ## │ ├── linear dimensional reduction-1.png ## │ ├── linear dimensional reduction-2.png ## │ ├── linear dimensional reduction-3.png ## │ ├── linear dimensional reduction-4.png ## │ ├── overlay spinal cord-1.png ## │ ├── overlay spinal cord-2.png ## │ ├── peptide-spectrum matches-1.png ## │ ├── peptide-spectrum matches-2.png ## │ ├── plot eiwit lengte en peptide aantal-1.png ## │ ├── plot eiwit lengte en peptide aantal-2.png ## │ ├── plot retentietijd en m ## │ │ └── z-1.png ## │ ├── plot rtime en m ## │ │ └── z pd-1.png ## │ ├── plotDensity quality control-1.png ## │ ├── plotDensity quality control-2.png ## │ ├── total ion chromatogram-1.png ## │ ├── unnamed-chunk-10-1.png ## │ ├── unnamed-chunk-11-1.png ## │ ├── unnamed-chunk-2-1.png ## │ ├── unnamed-chunk-3-1.png ## │ ├── unnamed-chunk-4-1.png ## │ ├── unnamed-chunk-7-1.png ## │ ├── unnamed-chunk-8-1.png ## │ ├── unnamed-chunk-9-1.png ## │ ├── variable features ad-1.png ## │ ├── variable features-1.png ## │ ├── visualisatie 10 MS2 spectra spinal cord-1.png ## │ ├── visualisatie MS1 en MS2 vb-1.png ## │ ├── visualisatie MS1 en MS2 vb-2.png ## │ ├── visualisatie MS2 pd-1.png ## │ ├── visualisatie MS2 spectra csf-1.png ## │ ├── visualisatie MS2 vb-1.png ## │ ├── visualisatie chromatogram pd-1.png ## │ ├── visualisatie chromatogram vb-1.png ## │ ├── visualitatie MS1 en MS2 csf-1.png ## │ ├── visualitatie MS1 en MS2 pd-1.png ## │ ├── visualitatie MS1 en MS2 pd-2.png ## │ ├── visualitatie MS1 en MS2 spinal cord-1.png ## │ ├── visualitatie MS1 en MS2 spinal cord-2.png ## │ ├── visualitatie MS1 en MS2-1.png ## │ └── visualitatie MS1 en MS2-2.png ## ├── amr.bib ## ├── daur2 ## │ ├── airway_rnaseq ## │ │ ├── README.txt ## │ │ ├── airway_rnaseq.Rmd ## │ │ ├── data ## │ │ │ ├── bam ## │ │ │ ├── count ## │ │ │ ├── fastqc ## │ │ │ └── genome_index ## │ │ ├── raw_data ## │ │ │ ├── GRCh38.primary_assembly.genome.fa.gz ## │ │ │ ├── rna_rawdata1.txt ## │ │ │ └── sample_data ## │ │ └── verslag ## │ ├── eindopdracht_daur2 ## │ │ ├── README.txt ## │ │ ├── data ## │ │ │ ├── bam ## │ │ │ ├── fastqc ## │ │ │ └── read_counts_OC1.rds ## │ │ ├── eindopdracht.Rmd ## │ │ └── raw_data ## │ │ ├── fastq ## │ │ └── sample_data.csv ## │ ├── ipsc_rnaseq ## │ │ ├── README.txt ## │ │ ├── data ## │ │ │ ├── bam ## │ │ │ ├── counts ## │ │ │ └── fastqc ## │ │ ├── ipsc_rnaseq.Rmd ## │ │ └── raw data ## │ │ ├── rawdata_ipsc.fastq ## │ │ ├── rawdata_ipsc1.fastq ## │ │ └── sample_data.txt ## │ ├── metagenomics_formative ## │ │ ├── data ## │ │ │ ├── bracken ## │ │ │ ├── fastqc ## │ │ │ └── kraken2 ## │ │ ├── metagenomics_formative.Rmd ## │ │ └── ruw_data ## │ │ └── fastq ## │ └── metagenomics_reader ## │ ├── README.txt ## │ ├── data ## │ │ ├── bracken ## │ │ │ └── mock1.bracken ## │ │ ├── fastqc ## │ │ └── kraken2 ## │ │ └── mock1 ## │ ├── metagenomics_reader.Rmd ## │ └── raw_data ## │ ├── HU1_MOCK1_L001_R1_001.fastq.gz ## │ ├── HU_waternet_MOCK1_composition.csv ## │ └── minikraken2_v2_8GB_201904_UPDATE ## ├── dsfb2_workflows_portfolio.Rproj ## ├── index.Rmd ## ├── opdracht9 ## │ ├── 08_opdracht_9.Rmd ## │ ├── 08_opdracht_9.html ## │ ├── test.Rmd ## │ └── test.html ## └── seurat_data ## └── ruwe data ## └── filtered_gene_bc_matrices ## └── hg19 ## ├── barcodes.tsv ## ├── genes.tsv ## └── matrix.mtx Workflows Exercises: fs::dir_tree(here::here(&quot;~/dsfb2/dsfb2_workflows_exercises/&quot;)) ## ~/dsfb2/dsfb2_workflows_exercises/ ## ├── README.md ## ├── data ## │ ├── FancySuppTable2.xls ## │ ├── salmonella CFU kinetics OD600 in LB van ipecs 8okt2020 kleur.xlsx ## │ ├── salmonella_cfu_kinetics_od600.csv ## │ └── toxrefdb_nel_lel_noael_loael_summary_AUG2014_FOR_PUBLIC_RELEASE-2.csv ## ├── dsfb2_workflows_exercises.Rproj ## ├── md5_examples ## │ ├── MD5_exampledata_1.txt ## │ ├── MD5_exampledata_backupcomputercrash.txt ## │ ├── MD5_exampledata_maybethisone.txt ## │ └── MD5_exampledata_savethisone.txt ## └── opdrachten_workflows ## ├── Rplot not cb.jpeg ## ├── Rplot_colorblind.jpeg ## ├── bibliography.json ## ├── friends.css ## ├── images ## │ ├── RossGeller.webp ## │ ├── Season_4_chandler.webp ## │ ├── bac435688f1410bb2b93770d2e5642e1.jpg ## │ ├── images.jpeg ## │ ├── jennifer-aniston-rachel-green-friends.jpg.webp ## │ └── phoebeprimary-12e7dbc2b11a48488f58d51a586a4c30.jpg ## ├── opdracht 8 ## │ ├── opdracht_8.1.Rmd ## │ ├── opdracht_8.1.docx ## │ ├── opdracht_8.1.html ## │ ├── opdracht_8.1.pdf ## │ ├── rabbit.Rmd ## │ ├── rabbit.html ## │ ├── test-report.Rmd ## │ ├── test-report.docx ## │ └── word-styles-reference-01.docx ## ├── opdrachten_les1.Rmd ## ├── opdrachten_les3.Rmd ## ├── opdrachten_les4.Rmd ## ├── opdrachten_les5.Rmd ## ├── opdrachten_les7.Rmd ## ├── opdrachten_les7.html ## ├── referencefriends.bib ## ├── test.Rmd ## └── test.html Workflows Projecticum: fs::dir_tree(here::here(&quot;~/dsfb2/AK_FFR_OC/&quot;)) ## ~/dsfb2/AK_FFR_OC/ ## ├── AK_FFR_OC.Rproj ## ├── FFR_testing_geomap ## │ └── map_display_test1.R ## ├── Isolation_date ## │ ├── app.R ## │ └── metadata.txt ## ├── nederland_map ## │ └── app.R ## ├── nl_map_in_app ## │ ├── app.R ## │ └── app.Rmd ## ├── original_app ## │ └── app.R ## └── visuele_opzet.Rmd "],["c.elegans-plate-experiment.html", "7 C.elegans plate experiment", " 7 C.elegans plate experiment Vraag A Ongewone observaties: - De data in kolom expDate is niet zichtbaar, in plaats daarvan kan je alleen #### zien. - De kolommen plateRow en plateColumn bevatten geen data. - Kolom bubble bevat alleen maar N/A. - Het kolom van de RawData loopt nog heel lang door, ondanks dat er geen data meer is op dat punt. Vraag B library(readxl) data_ce.liq.flow.062 &lt;- read_excel(&quot;~/Downloads/CE.LIQ.FLOW.062_Tidydata.xlsx&quot;) Vraag C Data types van de kolommen van het bestand: RawData = dbl compName = character compConcentration = character Wat zou ik verwachten op basis van de experimentele omschrijving? RawData: integer (een geheel getal) compName: character compConcentration = double (een concentratie met decimalen) De data types van RawData en van compConcentration zijn dan niet correct toegewezen. Vraag D library(tidyverse) ggplot(data = data_ce.liq.flow.062, aes(x = compConcentration, y = RawData)) + geom_point(aes(colour = compName, shape = expType)) + theme_classic() + theme(axis.text.x = element_text(angle = 90)) Vraag E De x-as is niet op volgorde van een kleine naar een grootte concentratie. Getallen ver in de min staan tussen getallen boven de 0 in. Dit komt doordat het data type van character klasse is, het wordt dan op volgorde van overeenkomende characters geordend, 0 dan 1 dan 2 enz. in plaats van op basis van de concentratie. E-3 wordt dan ook gezien als character en niet als een wetenschappelijke notatie. Vraag F library(dplyr) library(ggplot2) #compConcentration omzetten naar double data klasse data_ce.liq.flow.062_d &lt;- data_ce.liq.flow.062 %&gt;% mutate(compConcentration = sub(&quot;,&quot;,&quot;&quot;, compConcentration), compConcentration=as.double(compConcentration)) #x-axis omzetten naar log10 scale en gebruik jitter zodat de punten niet overlappen ggplot(data = data_ce.liq.flow.062_d, aes(x = compConcentration, y = RawData, colour = compName, shape = expType)) + geom_point(aes(colour = compName, shape = expType)) + geom_jitter() + theme_classic() + theme(axis.text.x = element_text(angle = 90)) + scale_x_log10() Vraag G &amp; H The positive control for this experiments is ethanol. The negative control for this experiment is S-medium. Vraag I Voor alle 3 de te testen composities (2,6-diisopropylnaphthalene, decane en naphthalen) zijn er voor elke concentratie 3 vials en uit elke vial worden er 5 metingen gedaan. De positieve, negatieve en vehicle control hebben vaste concentraties. Stappenplan analyse: MET COR.TEST 1. Van alle 3 de composities een apart object maken met de pipeline (voorbeeld 2,6-diisopropylnaphthalene): diisopropylnaphthalene &lt;- data_ce.liq.flow.062 %&gt;% filter(compName == “2,6-diisopropylnaphthalene”) 2. Een correlatie analyse uitvoeren voor elk van de 3 compensities met cor.test(). 3. Plot de data, x is de compConcentration en y is de RawData. MET ANOVA 1. Van alle 3 de composities een apart object maken met de pipeline (voorbeeld 2,6-diisopropylnaphthalene): diisopropylnaphthalene &lt;- data_ce.liq.flow.062 %&gt;% filter(compName == “2,6-diisopropylnaphthalene”) 2. Voor alle 3 de te testen composities per concentratie het gemiddelde en de standaardeviatie berekenen met de volgende pipeline: diisopropylnaphthalene_sum &lt;- diisopropylnaphthalene %&gt;% group_by(compConcentration) %&gt;% summarize(mean_progeny=mean(RawData), stdev=sd(RawData)) 3. Data plotten met de pipeline: diisopropylnaphthalene_sum %&gt;% ggplot(aes(x = compConcentration, y = mean_progeny, fill = compConcentration)) + geom_col() + geom_errorbar(aes(ymin = mean_progeny-stdev, ymax = mean_progeny+stdev), width = .2) + theme(axis.text.x = element_text(angle = 90)) 4. Checken voor normaliteit met de shapiro.wilk() optie, dit moet per concentratie gecheckt worden. 5. Uitvoeren van een ANOVA met de functie aov() en de resultaten bekijken met summary.aov(). Vraag J # Bereken de gemiddelde nakomelingen voor controlNegative controlNegative_mean &lt;- mean(data_ce.liq.flow.062_d$RawData[data_ce.liq.flow.062_d$expType == &quot;controlNegative&quot;], na.rm = TRUE) # Normaliseer de &#39;RawData&#39; voor &#39;controlNegative&#39; om een gemiddelde van 1 te krijgen data_normalized &lt;- data_ce.liq.flow.062_d %&gt;% mutate( RawData_norm = RawData / controlNegative_mean ) # Plot de genormaliseerde data ggplot(data = data_normalized, aes(x = compConcentration, y = RawData_norm, colour = compName, shape = expType)) + geom_point(aes(colour = compName, shape = expType)) + geom_jitter() + theme_classic() + theme(axis.text.x = element_text(angle = 90)) + scale_x_log10() Vraag K Om de negatieve controle als grondlijn/ referentie te nemen waarmee de rest van de ruwe data vergeleken kan worden. Door de andere condities als fractie van de negatieve controle te visualiseren worden de relatieve verschillen tussen de condities benadrukt, in plaats van de absolute metingen. "],["open-peer-review-reproducibility.html", "8 Open peer review: reproducibility 8.1 Part 1 8.2 Part 2", " 8 Open peer review: reproducibility 8.1 Part 1 Open science stelt onderzoeken meer open voor participatie, beoordeling/weerlegging, verbetering en hergebruik. Repita heeft acht transparantie criteria opgesteld waarmee de reproduceerbaarheid van een onderzoek geëvalueerd kan worden. Het artikel dat in deze opdracht wordt geëvalueerd is “Glycomic and Proteomic Changes in Aging Brain Nigrostriatal Pathway”. Het algemene doel van dit artikel is het bepalen van het effect van leeftijdsgerelateerde veranderingen in glycaan receptoren op de binding van Adeno-associated virussen. Gen therapie met Adeno-associated virussen is succesvol geweest in pre-klinische modellen van de ziekte van Parkinson, echter bij klinische trials met mensen is het niet efficiënt bewezen. Het leeftijdsonderzoek werd uitgevoerd op zes jonge en zes oude mannelijke F344 ratten. De hersenen van de ratten zijn post-mortum gesectioneerd, na meerdere rondes van digestie konden hieruit de te onderzoeken glycan en proteomen worden geëxtraheert. Vervolgens is er een HILIC-MS of LC-MS analyse uitgevoerd op de samples, waarna de data is geanalyseerd met verscheidene pakketten en softwares. Verschillende brein regio-specifieke HS disaccharide profielen waren waargenomen in oude vergeleken met jonge ratten. Ook waren er brein regio- en leeftijdsspecifieke N-glycaan profielen waargenomen. In het nigrostriatale pathway van oude ratten zijn ook veranderingen in brein regio-specifieke eiwit-expressie waargenomen. De evaluatie van de acht criteria is in het onderstaande tabel weergeven. Per criteria zal ik nog verdere uitleg geven waarom ik voor de score heb gekozen. De aanleiding voor het artikel is aanwezig, de onderzoekers vertellen eerst over AAV als gen therapie en hoe dit niet effectief is in mensen. Hierbij geven ze aan waarom zij denken dat het niet werkt en gaan vervolgens in het onderzoek achterhalen of dit klopt. Er is een data availability statement aanwezig, de data is bereikbaar op de PRIDE repository met project accession nummer PXD008990. De locatie van de data is ook weergeven, met een link naar de PRIDE repository; https://www.ebi.ac.uk/pride/archive?keyword=PXD008990. De study location is niet genoemd in de methodes van het artikel. Author review heeft als score Tier 3, dit houdt in dat de auteur zijn/haar instituuts e-mail adress heeft gebruikt als primair contact. Wel is dit maar bij een van de auteurs genoteerd. Een ethics statement is ook niet aanwezig in dit artikel. Een funding statement is weergeven, de funding was verstrekt door NIH grants P41GM104603, R21CA177479, and R56AG052328. De code availability is ook weergeven, onder andere Peak Studio versie 8.0 en GlyReSoft versie 0.3.1 waren gebruikt voor de analyse van de data. 6 van de 8 criteria zijn transparant, hiermee zou ik concluderen dat de data reproduceerbaar is, maar er is wel nog ruimte voor verbetering. De ethische statements en de study locatie moeten nog weergeven worden om te voldoen aan de 8 criteria. library(tidyverse) knitr::kable( tibble( &quot;Transparency Criteria&quot; = c(&quot;Study purpose&quot;, &quot;Data availability statement&quot;, &quot;Data location&quot;, &quot;Study location&quot;, &quot;Author review&quot;, &quot;Ethics statement&quot;, &quot;Funding statement&quot;, &quot;Code availability&quot;), &quot;Definition&quot; = c(&quot;A concise statement in the introduction of the article, often in the last paragraph, that establishes the reason the research was conducted. Also called the study objective.&quot;, &quot;A statement, in an individual section offset from the main body of text, that explains how or if one can access a study’s data. The title of the section may vary, but it must explicitly mention data; it is therefore distinct from a supplementary materials section.&quot;, &quot;Where the article’s data can be accessed, either raw or processed.&quot;, &quot;Author has stated in the methods section where the study took place or the data’s country/region of origin.&quot;, &quot;The professionalism of the contact information that the author has provided in the manuscript.&quot;, &quot;A statement within the manuscript indicating any ethical concerns, including the presence of sensitive data.&quot;, &quot;A statement within the manuscript indicating whether or not the authors received funding for their research.&quot;, &quot;Authors have shared access to the most updated code that they used in their study, including code used for analysis.&quot;), &quot;Response Type&quot; = c(&quot;Binary&quot;, &quot;Binary&quot;, &quot;Found Value&quot;, &quot;Binary; Found Value&quot;, &quot;Found Value&quot;, &quot;Binary&quot;, &quot;Binary&quot;, &quot;Binary&quot;), &quot;Score&quot; = c(&quot;Yes&quot;, &quot;Yes&quot;, &quot;External Repository; PRIDE&quot;, &quot;No&quot;, &quot;Tier 3&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Yes&quot;) )) Transparency Criteria Definition Response Type Score Study purpose A concise statement in the introduction of the article, often in the last paragraph, that establishes the reason the research was conducted. Also called the study objective. Binary Yes Data availability statement A statement, in an individual section offset from the main body of text, that explains how or if one can access a study’s data. The title of the section may vary, but it must explicitly mention data; it is therefore distinct from a supplementary materials section. Binary Yes Data location Where the article’s data can be accessed, either raw or processed. Found Value External Repository; PRIDE Study location Author has stated in the methods section where the study took place or the data’s country/region of origin. Binary; Found Value No Author review The professionalism of the contact information that the author has provided in the manuscript. Found Value Tier 3 Ethics statement A statement within the manuscript indicating any ethical concerns, including the presence of sensitive data. Binary No Funding statement A statement within the manuscript indicating whether or not the authors received funding for their research. Binary Yes Code availability Authors have shared access to the most updated code that they used in their study, including code used for analysis. Binary Yes 8.2 Part 2 Geselecteerd project: Link: https://osf.io/324jm/ Beschrijf in eigen worden wat de intentie van de code is. Met behulp van algemene additieve gemengde modellen (GAMMs) proberen ze na te gaan wat het effect van lineaire en log-getransformeerde cloze probability op het verband tussen de woordvoorspelbaarheid en de leestijd. In terms of readibility of the code, how would you grade (1(very bad)-5(very good)) the code available. Ik zou het een 4 geven, er wordt niet duidelijk uitgelegd waarom bepaalde functies worden gebruikt of wat er wordt uitgevoerd. Verder is de code wel duidelijk en is er goede structuur waarbij headers zijn gebruikt. Run the script or code that is available to reproduce at least 1 figure Experiment 1 Raw cloze probability: dat = read.csv(file=&quot;../../Downloads/osfstorage-archive/data_and_materials/SPRT_LogLin_216.csv&quot;,head=T) lin_gam=mgcv::gam(SUM_3RT_trimmed ~s(c_cloze) + s(SUB,bs=&quot;re&quot;)+ s(ITEM,bs= &quot;re&quot;), data=dat, method = &quot;REML&quot;) #summary(lin_gam) mgcv::plot.gam(lin_gam, select = 1) #y_pred &lt;- predict(lin_gam, data.frame(x = x_new)) Log-transformed cloze probability: log_gam=mgcv::gam(SUM_3RT_trimmed ~ s(c_log_cloze) + s(SUB,bs=&quot;re&quot;)+ s(ITEM,bs= &quot;re&quot;), data=dat, method = &quot;REML&quot;) mgcv::plot.gam(log_gam, select = 1) Experiment 2 Trying to reproduce GAMMs analysis. Raw cloze probability: dat2 = read.csv(file=&quot;data_and_materials/LogLin_Naming.csv&quot;,head=T) lin_gam=mgcv::gam(TRIM_RT ~s(c_cloze) + s(subject,bs=&quot;re&quot;)+ s(item,bs= &quot;re&quot;), data=dat2, method = &quot;REML&quot;) mgcv::plot.gam(lin_gam, select = 1) Log-transformed cloze probability: log_gam=mgcv::gam(TRIM_RT ~ s(c_log_cloze) + s(subject,bs=&quot;re&quot;)+ s(item,bs= &quot;re&quot;), data=dat2, method = &quot;REML&quot;) mgcv::plot.gam(log_gam, select = 1) Taken together on a scale from 1 (very hard) to 5 (very easy), how much effort did it take you to reproduce the visualization from the project, report or article? Ik zou het overall een 3,5 geven, ik heb de visualisatie van 2 experimenten uitgevoerd. Experiment 1 ging in een keer zonder errors of flaws. Bij experiment 2 kreeg ik wel een error: ‘names’ attribute [1] must be the same length as the vector [0]. Aangezien ik wat data/ uitleg bij deze code mis lukt het me niet over welke attribute en vector het gaat. Het is me niet gelukt om deze code op te lossen. Ik mis verder wel metadata en een README file. "],["create-a-package.html", "9 Create a package", " 9 Create a package Onesample is een package waarmee een one-sample t-test en de voorgaande controles makkelijk uit te voeren zijn. Onesample kan gedownload worden met de volgende command lijn: devtools::install_github(\"cheryloort/onesample\", dependencies = TRUE, build_vignettes = TRUE) Het vignet is toegankelijk met de volgende command lijn: vignette(\"onesample\") "],["projecticum-antimicrobiële-resistentie-amr.html", "10 Projecticum Antimicrobiële Resistentie (AMR)", " 10 Projecticum Antimicrobiële Resistentie (AMR) Antimicrobiële resistentie (AMR) houdt in dat bacteriën, virussen, schimmels en parasieten ongevoelig worden voor behandeling met antimicrobiële middelen. Antimicrobiële middelen worden gebruikt voor het voorkomen en behandelen van infectieziekten en tot deze middelen horen onder andere antibiotica, antivirale middelen, antischimmelmiddelen en antiparasitaire middelen. Resistentie voor deze middelen verhoogd het risico op verspreiding van ziekten, ernstige ziekten, invaliditeit en overlijden doordat de infecties moeilijk of onmogelijk behandeld kunnen worden [@AntimicrobialResistance]. Een microbe kan ook een resistentie ontwikkelen voor meerdere antimicrobiële middelen, in dat geval wordt er gesproken van een multi-drug resistent organisme (MDRO). Voorbeelden van MDRO’s zijn MRSA, VRE, CRE, ESBLs, CR-AB, MDR, CD en mycobacterium tuberculosis. Zieke en verzwakte patiënten zijn gevoeliger voor MDRO’s en daardoor zijn de MDRO’s voornamelijk problematisch in ziekenhuizen. MDRO’s kunnen overgegeven worden via lucht, contact met besmette oppervlaktes, medische apparatuur en door zorgmedewerkers [@guRiskMultidrugresistantOrganism2023]. Het ontwikkelen van een antimicrobiële resistentie is een natuurlijk proces in de microben. Wel kan het ontwikkelingsproces versneld worden door bijvoorbeeld onjuist gebruik of overmatig gebruik van antimicrobiële middelen, door slechte hygiëne, door een gebrek aan preventie en door reizen, waardoor de pathogeen verspreid wordt [@resistanceWhatCausesAMR2017]. Genetische veranderingen maken het mogelijk voor de microbe om te overleven. Deze genetische veranderingen kunnen op meerdere manieren ontstaan: - Doormiddel van selectie: als een microbe een resistent gen bevat en een behandeling met een antimicrobieel middel overleeft zal deze gaan repliceren. De nakomelingen zullen dominant worden in de populatie. - Door mutaties kan er een verandering optreden waardoor een microbe resistent kan worden voor bepaalde antimicrobiële middelen. - Resistente bacteriën kunnen aan niet resistente bacteriën een kopie overdragen van hun DNA (in de vorm van een plasmide), waardoor ook deze bacteriën resistent worden [@CausesAntimicrobialDrug2011]. Er zijn verschillende mechanismen waarmee antimicrobiële resistentie kan worden verkregen in microben. De binnenkomst van de antimicrobiële middelen kan beperkt worden, bijvoorbeeld doordat het membraan van de microben minder permeabel wordt voor de middelen. Ook kunnen er efflux pompen in overschot in de membranen terecht komen door mutaties, de antimicrobiële middelen worden dan met een hoog tempo uit de cel gepompt. De bindingsplaats van de antimicrobiële middelen kan verhinderd worden door methylatie van het DNA of door 16s RNA’s. Hydrolytische enzymen kunnen ook worden ingezet om antimicrobiële middelen af te breken [@bharadwajMultidrugResistantBacteriaTheir2022]. Plasmides zijn belangrijk bij de ontwikkeling van AMR/MDR. Met behulp van bijvoorbeeld DNA microarray detectie kan er onderzoek gedaan worden naar resistentie gerelateerde genen in plasmiden [@huangCharacteristicsPlasmidsMultiDrugResistant2012]. In het projecticum “AMR” wordt de data van de AMRO/MDRO in een overzichtelijke shiny app weergeven. De data bestaat onder andere uit de plasmiden, het soort AMRO/MDRO, de NCBI genen, isolatie datum en isolatie instituut. Het uiteindelijke doel van dit project is om de plasmide genomen te analyseren. "],["ecdc-covid-19-cases-data-parameterization.html", "11 ECDC COVID-19 cases data parameterization", " 11 ECDC COVID-19 cases data parameterization De onderstaande code is voor het gebruik toegevoegd aan de YAML header. params: country: “Austria” year: 2022 month: 1 data &lt;- read.csv(&quot;https://opendata.ecdc.europa.eu/covid19/nationalcasedeath_eueea_daily_ei/csv&quot;, na.strings = &quot;&quot;, fileEncoding = &quot;UTF-8-BOM&quot;) # Filter the country of interest that will be plotted filtered_data &lt;- data %&gt;% filter(countriesAndTerritories == &quot;Austria&quot;, #Anders == params$country year == 2022, #Anders == params$year month == 1) #Anders == params$month plot_ly(filtered_data, x = ~day, y = ~cases, type = &#39;bar&#39;, text = ~paste(&quot;Day: &quot;, day, &quot;&lt;br&gt;Cases: &quot;, cases), hoverInfo = &#39;text&#39;) %&gt;% layout(title = paste(&quot;COVID-19 Cases in Austria in maand 1 van 2022&quot;), #Anders &quot;COVID-19 Cases in&quot;, params$country, &quot;in maand&quot;, params$month, &quot;van&quot;, params$year xaxis = list(title = &quot;Day&quot;), yaxis = list(title = &quot;Number of Cases&quot;)) plot_ly(filtered_data, x = ~day, y = ~deaths, type = &#39;bar&#39;, text = ~paste(&quot;Day: &quot;, day, &quot;&lt;br&gt;Deaths: &quot;, deaths), hoverInfo = &#39;text&#39;) %&gt;% layout(title = paste(&quot;COVID-19 Deaths in Austria in maand 1 van 2022&quot;), #Anders &quot;COVID-19 Deaths in&quot;, params$country, &quot;in maand&quot;, params$month, &quot;van&quot;, params$year xaxis = list(title = &quot;Day&quot;), yaxis = list(title = &quot;Number of Deaths&quot;)) In het document buiten bookdown om zijn de #Anders comments gebruikt als code. Daarnaast heb ik ook een interactieve params sectie gecreëerd: hieronder is de YAML header set up weergeven, de rest van de code is precies hetzelfde (met de filter == params$country/year/month). title: “Portfolio” output: html_document params: country: label: “Select a country:” value: “Austria” input: select choices: [“Austria”, “Belgium”, “Bulgaria”, “Croatia”, “Cyprus”, “Czechia”,“Denmark”, “Estonia”, “Finland”, “France”, “Germany”, “Greece”, “Hungary”, “Iceland”, “Ireland”, “Italy”, “Latvia”, “Liechtenstein”, “Lithuania”, “Luxembourg”, “Malta”, “Netherlands”, “Norway”, “Poland”, “Portugal”, “Romania”, “Slovakia”, “Slovenia”, “Spain”, “Sweden”] year: label: “Select a year:” value: 2020 input: select choices: [2020,2021,2022] month: label: “Select a month:” value: 1 input: slider min: 1 max: 12 step: 1 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
